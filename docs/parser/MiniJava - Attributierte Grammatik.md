# MiniJava 4.0 - Attributierte Grammatik

Note: Use
* http://waylonflinn.github.io/markdown-it-katex/ or
* vscode or
* another katex-able Markdown-Viewer

to view this file

$ $                                 | $ $   | $  $                                                                                                                                              | $ $ | Semantische Regeln
---:                                | :---: | :---                                                                                                                                              | :-- | :--
$Program$                           | $\to$ | $ClassDeclaration^ \ast$                                                                                                                          | $ $ | $Programm$.node = new Program(classes = concatAll(List($ClassDeclaration_i$)))
$ClassDeclaration$                  | $\to$ | **`class IDENT {`** $ClassMember^ \ast$ **`}`**                                                                                                   | $ $ | $ClassDeclaration$.node = new Class( <br />&emsp;name = **IDENT**.name <br/>&emsp;members = concatAll(List($ClassMember_i$.node)) <br />)
$ClassMember$                       | $\to$ | **`public`** $MethodPrefix$                                                                                                                       | $ $ | $ClassMember$.node = $MethodPrefix$.node
$MethodPrefix$                      | $\to$ | $FieldMethodPrefix$                                                                                                                               | $ $ | $MethodPrefix$.node = $FieldMethodPrefix$.node
$MethodPrefix$                      | $\to$ | $MainMethod$                                                                                                                                      | $ $ | $MethodPrefix$.node = $MainMethod$.node
$FieldMethodPrefix$                 | $\to$ | $Type$ **`IDENT`** $FieldMethodRest$                                                                                                              | $ $ | $FieldMethodPrefix$.node = $FieldMethodRest$.node  <br/> $FieldMethodRest$.name = IDENT.name  <br/> $FieldMethodRest$.type = $Type$.node
$FieldMethodRest$                   | $\to$ | $Field$                                                                                                                                           | $ $ | $FieldMethodRest$.node = $Field$.node <br/> $Field$.name = $FieldMethodRest$.name  <br/> $Field$.type = $FieldMethodRest$.type
$FieldMethodRest$                   | $\to$ | $Method$                                                                                                                                          | $ $ | $FieldMethodRest$.node = $Method$.node <br/> $Method$.name = $FieldMethodRest$.name  <br/> $Method$.type = $FieldMethodRest$.type
$Field$                             | $\to$ | **`;`**                                                                                                                                           | $ $ | $Field$.node = new Field(name = $Field$.name, type = $Field$.type)
$Method$                            | $\to$ | **`(`** $Parameters?$ **`)`** $MethodRest ?$ $Block$                                                                                              | $ $ | $Method$.node = new Method(<br />&emsp;name = $Method$.name,<br />&emsp;returnType = $Method$.type,<br />&emsp;parameters = $Parameters$?.node ?: List(),<br />&emsp;throwException = $MethodRest?$.exception,<br />&emsp;block = $Block$.node<br />)
$MainMethod$                        | $\to$ | **`static void IDENT (`** $Type$ **`IDENT )`** $MethodRest ?$ $Block$                                                                             | $ $ | $MainMethod$.node = new MainMethod(<br />&emsp;name = **IDENT1**.name,<br />&emsp;type = Type.Void,<br />&emsp;parameters = List(new Parameter(type = $Type$.node, name = **IDENT2**.name)),<br />&emsp;throwException = $MethodRest?$.exception,<br />&emsp;block = $Block$.node<br />)
$MethodRest$                        | $\to$ | **`throws IDENT`**                                                                                                                                | $ $ | $MethodRest$.exception = **IDENT**.name
$Parameters$                        | $\to$ | $Parameter$ $($ **`,`** $Parameter$ $)*$                                                                                                          | $ $ | $Parameters$.node = concatAll(List($Parameter_i$.node))
$Parameter$                         | $\to$ | $Type$ **`IDENT`**                                                                                                                                | $ $ | $Parameter$.node = new Parameter(type = $Type$.node, name = **IDENT**.name)
$ $                                 | $ $   | $ $                                                                                                                                               | $ $ |
$Type$                              | $\to$ | $BasicType$ $($ **`[ ]`** $)*$                                                                                                                    | $ $ | $Type$.node = wrapType&lt;Array&gt;($BasicType$.node, number of **[ ]**)
$BasicType$                         | $\to$ | **`int`**                                                                                                                                         | $ $ | $Type$.node = Type.Integer
$BasicType$                         | $\to$ | **`boolean`**                                                                                                                                     | $ $ | $Type$.node = Type.Boolean
$BasicType$                         | $\to$ | **`void`**                                                                                                                                        | $ $ | $Type$.node = Type.Void
$BasicType$                         | $\to$ | **`IDENT`**                                                                                                                                       | $ $ | $Type$.node = new Type.Class(name = **IDENT**.name)
$ $                                 | $ $   | $ $                                                                                                                                               | $ $ |
$Statement$                         | $\to$ | $Block$ <br/>$\|$ $EmptyStatement$ <br/>$\|$ $IfStatement$ <br/>$\|$ $ExpressionStatement$ <br/>$\|$ $WhileStatement$ <br/>$\|$ $ReturnStatement$ | $ $ | $Statement$.node = $\{$<br />&emsp;$Block$ $\|$ $EmptyStatement$ $\|$ $IfStatement$<br />&emsp;$\|$ $ExpressionStatement$ $\|$ $WhileStatement$ $\|$ $ReturnStatement$<br />$\}$.node
$Block$                             | $\to$ | **`{`** $BlockStatement^ \ast$ **`}`**                                                                                                            | $ $ | $Block$.node = new Block(statements = concatAll(List($BlockStatement_i$.node)))
$BlockStatement$                    | $\to$ | $Statement$ $\|$ $LocalVariableDeclarationStatement$                                                                                              | $ $ | $BlockStatement$.node = $\{$<br />&emsp;$Statement$ $\|$ $LocalVariableDeclarationStatement$<br />$\}$.node
$LocalVariableDeclarationStatement$ | $\to$ | $Type$ **`IDENT`** $($ **`=`** $Expression )?$ **`;`**                                                                                            | $ $ | $LocalVariableDeclarationStatement$.node =<br />&emsp;new LocalVariableDeclarationStatement(<br />&emsp;&emsp;name = **IDENT**.name,<br />&emsp;&emsp;type = $Type$.node,<br />&emsp;&emsp;initializer = $Expression$?.node<br />&emsp;)
$EmptyStatement$                    | $\to$ | **`;`**                                                                                                                                           | $ $ | $EmptyStatement$.node = new Block(statements = List())
$WhileStatement$                    | $\to$ | **`while (`** $Expression$ **`)`** $Statement$                                                                                                    | $ $ | $WhileStatement$.node = new WhileStatement(<br />&emsp;condition = $Expression$.node,<br />&emsp;statement = $Statement$.node<br />)
$IfStatement$                       | $\to$ | **`if (`** $Expression$ **`)`** $Statement$ $($ **`else`** $Statement$ $)?$                                                                       | $ $ | $IfStatement$.node = new IfStatement(<br />&emsp;condition = $Expression$.node,<br />&emsp;trueStatement = $Statement_1$.node,<br />&emsp;falseStatement = $Statement_2$?.node<br />)
$ExpressionStatement$               | $\to$ | $Expression$ **`;`**                                                                                                                              | $ $ | $ExpressionStatement$.node = new ExpressionStatement(<br />&emsp;expression = $Expression$.node<br />)
$ReturnStatement$                   | $\to$ | **`return`** $Expression ?$ **`;`**                                                                                                               | $ $ | $ReturnStatement$.node = new ReturnStatement(<br />&emsp;expression = $Expression$?.node<br />)
$ $                                 | $ $   | $ $                                                                                                                                               | $ $ |
$Expression$                        | $\to$ | <span style="color:green">*See Precedence Table*</span>                                                                                           | $ $ | TODO
$\dots$                             | $\dots$   | $\dots$                                                                                                                                       | $ $ |
$UnaryExpression$                   | $\to$ | $PostfixExpression$                                                                                                                               | $ $ | $UnaryExpression$.node = $PostfixExpression$.node
$UnaryExpression$                   | $\to$ | $($ **`!`** $\|$ **`-`** $)$  $UnaryExpression$                                                                                                   | $ $ | $UnaryExpression_1$.node = new UnaryExpression(<br />&emsp;expression = $UnaryExpression_2$.node,<br />&emsp;operation = $\{$ `!` $\|$ `-` $\}$.operation<br />)
$PostfixExpression$                 | $\to$ | $PrimaryExpression$ $(PostfixOp)^*$                                                                                                               | $ $ | if (keine $PostfixOp$) {<br />&emsp;$PostfixExpression$.node = $PrimaryExpression$.node<br />} else {<br />&emsp;$PostfixOp_0$.primary = $PrimaryExpression$.node<br />&emsp;$PostfixOp_i$.primary = $PostfixOp_{i - 1}$.node<br />&emsp;$PostfixExpression$.node = $PostfixOp_n$.node<br />}
$PostfixOp$                         | $\to$ | $FieldAccess$ <br/>$\|$ $ArrayAccess$ <br />$\|$ $MethodInvocation$<br />($=: Child$)                                                             | $ $ | $Child$.primary = $PostfixOp$.primary<br />$PostfixOp$.node = $Child$.node
$FieldAccess$                       | $\to$ | **`. IDENT`**                                                                                                                                     | $ $ | $FieldAccess$.node = new FieldAccessExpression(<br />&emsp;target = $FieldAccess$.primary,<br />&emsp;field = **IDENT**.name<br />)
$ArrayAccess$                       | $\to$ | **`[`** $Expression$ **`]`**                                                                                                                      | $ $ | $ArrayAccess$.node = new ArrayAccessExpression(<br />&emsp;target = $ArrayAccess$.primary,<br />&emsp;index = $Expression$.node<br />)
$MethodInvocation$                  | $\to$ | **`. IDENT (`** $Arguments$ **`)`**                                                                                                               | $ $ | $MethodInvocation$.node = new MethodInvocationExpression(<br />&emsp;target = $MethodInvocation$.primary,<br />&emsp;method = **IDENT**.name,<br />&emsp;arguments = $Arguments$.node<br />)
$Arguments$                         | $\to$ | $( Expression$ $($ **`,`** $Expression)^ \ast)?$                                                                                                  | $ $ | $Arguments$.node = concatAll(List($Expression_i$.node))
$PrimaryExpression$                 | $\to$ | **`null`**                                                                                                                                        | $ $ | $PrimaryExpression$.node = TODO
$PrimaryExpression$                 | $\to$ | **`false`**                                                                                                                                       | $ $ | $PrimaryExpression$.node = new LiteralExpression&lt;Boolean&gt;(value = false)
$PrimaryExpression$                 | $\to$ | **`true`**                                                                                                                                        | $ $ | $PrimaryExpression$.node = new LiteralExpression&lt;Boolean&gt;(value = true)
$PrimaryExpression$                 | $\to$ | **`INTEGER_LITERAL`**                                                                                                                             | $ $ | $PrimaryExpression$.node = new LiteralExpression&lt;Integer&gt;(<br />&emsp;value = **INTEGER_LITERAL**.value<br />)
$PrimaryExpression$                 | $\to$ | **`IDENT`**                                                                                                                                       | $ $ | $PrimaryExpression$.node = new IdentifierExpression(name = **IDENT**.name)
$PrimaryExpression$                 | $\to$ | **`IDENT`** $($ **`(`** $Arguments$ **`)`**$)$                                                                                                    | $ $ | $PrimaryExpression$.node = new MethodInvocationExpression(<br />&emsp;type =<br />&emsp;length =<br />target = TODO (this),<br />&emsp;method = **IDENT**.name,<br />&emsp;arguments = $Arguments$.node<br />)
$PrimaryExpression$                 | $\to$ | **`this`**                                                                                                                                        | $ $ | $PrimaryExpression$.node = TODO
$PrimaryExpression$                 | $\to$ | **`(`** $Expression$ **`)`**                                                                                                                      | $ $ | $PrimaryExpression$.node = $Expression$.node
$PrimaryExpression$                 | $\to$ | **`new`** $NewObjectArrayExpression$                                                                                                              | $ $ | $PrimaryExpression$.node = $NewObjectArrayExpression$.node
$NewObjectArrayExpression$          | $\to$ | $NewObjectExpression$ <br />$\|$ $NewArrayExpression$ <br />($=: Child$)                                                                          | $ $ | $NewObjectArrayExpression$.node = $Child$.node
$NewObjectExpression$               | $\to$ | **`IDENT ( )`**                                                                                                                                   | $ $ | $NewObjectExpression$.node = new NewObjectExpression(clazz = **IDENT**.name)
$NewArrayExpression$                | $\to$ | $BasicType$ **`[`** $Expression$ **`]`** $($ **`[ ]`** $)^ \ast$                                                                                  | $ $ | $NewArrayExpression$.node = new NewArrayExpression(<br />&emsp;type = wrapType&lt;Array&gt;($BasicType$.node, number of **[ ]**)<br />&emsp;length = $Expression$.node<br />)

```
function wrapType<T>(type: Type, n: Integer) {
    repeat n times {
        type = new T(type)
    }
    return type
}
```
