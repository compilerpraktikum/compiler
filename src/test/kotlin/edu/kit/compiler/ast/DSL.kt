package edu.kit.compiler.ast

import edu.kit.compiler.ast.AST.wrapBlockStatement
import edu.kit.compiler.lex.SourceFile
import edu.kit.compiler.lex.SourcePosition
import edu.kit.compiler.lex.SourceRange
import edu.kit.compiler.lex.StringTable
import edu.kit.compiler.lex.Symbol
import edu.kit.compiler.wrapper.wrappers.Parsed

abstract class AstDsl<T>(var res: MutableList<T> = mutableListOf())

/**
 * **ONLY** use for testing in the DSL below. Real identifiers need to be converted to symbols using the [StringTable].
 */
private fun String.toSymbol() = Symbol(this, isKeyword = false)

private val ILLEGAL_SOURCE_FILE = SourceFile.from("[MOCKED SOURCE STREAM]", "")

/**
 * **ONLY** use for testing in the DSL below. It will assign illegal source positions to AST nodes, that must be ignored.
 * ASTs generated by this must not be given into code analysis or other subsequent compilation phases. They can only be
 * used for comparison to generated ASTs.
 */
internal fun <T> T.wrapMockValid(): Parsed.Valid<T> {
    return Parsed.Valid(SourceRange(SourcePosition(ILLEGAL_SOURCE_FILE, 0), 0), this)
}

class ClassDeclarationDsl(res: MutableList<Parsed<AST.ClassDeclaration>> = mutableListOf()) :
    AstDsl<Parsed<AST.ClassDeclaration>>(res) {
    fun clazz(name: String, block: ClassMemberDsl.() -> Unit) {
        val members = ClassMemberDsl().also { it.block() }
        this.res.add(
            AST.ClassDeclaration(
                name.toSymbol().wrapMockValid(),
                members.res
            ).wrapMockValid()
        )
    }
}

class ClassMemberDsl(res: MutableList<Parsed<AST.ClassMember>> = mutableListOf()) :
    AstDsl<Parsed<AST.ClassMember>>(res) {

    fun param(name: String, type: Type) = AST.Parameter(name.toSymbol().wrapMockValid(), type.wrapMockValid())

    fun field(name: String, type: Type) {
        this.res.add(AST.Field(name.toSymbol().wrapMockValid(), type.wrapMockValid()).wrapMockValid())
    }

    fun mainMethod(
        name: String,
        returnType: Type,
        vararg parameters: AST.Parameter,
        throws: String? = null,
        block: BlockStatementDsl.() -> Unit
    ) {

        this.res.add(
            AST.MainMethod(
                name.toSymbol().wrapMockValid(),
                returnType.wrapMockValid(),
                parameters.toList().map { it.wrapMockValid() },
                AST.Block(BlockStatementDsl().also(block).res).wrapMockValid(),
                throws?.toSymbol()?.wrapMockValid()
            ).wrapMockValid()
        )
    }

    fun method(
        name: String,
        returnType: Type,
        vararg parameters: AST.Parameter,
        throws: String? = null,
        block: BlockStatementDsl.() -> Unit
    ) {
        this.res.add(
            AST.Method(
                name.toSymbol().wrapMockValid(),
                returnType.wrapMockValid(),
                parameters.toList().map { it.wrapMockValid() },
                AST.Block(BlockStatementDsl().also(block).res).wrapMockValid(),
                throws?.toSymbol()?.wrapMockValid()
            ).wrapMockValid()
        )
    }
}

object ExprDsl {
    fun <T> literal(v: T) = AST.LiteralExpression(v)
    fun binOp(
        op: AST.BinaryExpression.Operation,
        left: ExprDsl.() -> AST.Expression,
        right: ExprDsl.() -> AST.Expression
    ) =
        AST.BinaryExpression(ExprDsl.left().wrapMockValid(), ExprDsl.right().wrapMockValid(), op)

    fun ident(name: String) = AST.IdentifierExpression(name.toSymbol().wrapMockValid())

    fun arrayAccess(
        target: ExprDsl.() -> AST.Expression,
        index: ExprDsl.() -> AST.Expression
    ) = AST.ArrayAccessExpression(ExprDsl.target().wrapMockValid(), ExprDsl.index().wrapMockValid())

    fun fieldAccess(
        left: ExprDsl.() -> AST.Expression,
        field: String
    ) = AST.FieldAccessExpression(ExprDsl.left().wrapMockValid(), field.toSymbol().wrapMockValid())

    fun newArrayOf(
        type: Type.Array.ArrayType,
        length: ExprDsl.() -> AST.Expression
    ) = AST.NewArrayExpression(type.wrapMockValid(), ExprDsl.length().wrapMockValid())
}

class BlockStatementDsl(val res: MutableList<Parsed<AST.BlockStatement>> = mutableListOf()) {
    fun localDeclaration(
        name: String,
        type: Type,
        initializer: (ExprDsl.() -> AST.Expression)? = null
    ) {
        res.add(
            AST.LocalVariableDeclarationStatement(
                name.toSymbol().wrapMockValid(), type.wrapMockValid(),
                if (initializer != null) {
                    ExprDsl.initializer().wrapMockValid()
                } else null
            ).wrapMockValid()
        )
    }

    fun emptyStatement() = res.add(AST.StmtWrapper(AST.emptyStatement).wrapMockValid())
    fun block(b: BlockStatementDsl.() -> Unit) {
        res.add(AST.StmtWrapper(AST.Block(BlockStatementDsl().also(b).res)).wrapMockValid())
    }

    fun expressionStatement(expr: ExprDsl.() -> AST.Expression) {
        res.add(AST.StmtWrapper(AST.ExpressionStatement(ExprDsl.expr().wrapMockValid())).wrapMockValid())
    }

    fun ifStmt(
        cond: ExprDsl.() -> AST.Expression,
        trueStmt: StatementDsl.() -> AST.Statement,
        falseStmt: (StatementDsl.() -> AST.Statement)? = null
    ) = res.add(StatementDsl.ifStmt(cond, trueStmt, falseStmt).wrapBlockStatement().wrapMockValid())
}

object StatementDsl {
    fun ifStmt(
        cond: ExprDsl.() -> AST.Expression,
        trueStmt: StatementDsl.() -> AST.Statement,
        falseStmt: (StatementDsl.() -> AST.Statement)? = null
    ) = AST.IfStatement(
        ExprDsl.cond().wrapMockValid(),
        StatementDsl.trueStmt().wrapMockValid(),
        falseStmt?.let { StatementDsl.it().wrapMockValid() }
    )
}

class StatementsDsl(val res: MutableList<Parsed<AST.Statement>> = mutableListOf()) {
    fun block(b: StatementsDsl.() -> Unit) {
        res.add(AST.Block(StatementsDsl().also(b).res.map { it.map { it.wrapBlockStatement() } }).wrapMockValid())
    }

    fun ifStmt(
        cond: ExprDsl.() -> AST.Expression,
        trueStmt: StatementDsl.() -> AST.Statement,
        falseStmt: (StatementDsl.() -> AST.Statement)? = null
    ) = res.add(StatementDsl.ifStmt(cond, trueStmt, falseStmt).wrapMockValid())
}

fun astOf(block: ClassDeclarationDsl.() -> Unit) =
    ClassDeclarationDsl().also(block).res
