package edu.kit.compiler.ast

import edu.kit.compiler.lexer.StringTable
import edu.kit.compiler.lexer.Symbol
import edu.kit.compiler.source.SourceFile
import edu.kit.compiler.source.SourcePosition
import edu.kit.compiler.source.SourceRange
import edu.kit.compiler.wrapper.wrappers.Parsed

abstract class AstDsl<T>(var res: MutableList<T> = mutableListOf())

/**
 * **ONLY** use for testing in the DSL below. Real identifiers need to be converted to symbols using the [StringTable].
 */
private fun String.toSymbol() = Symbol(this, isKeyword = false)

private val ILLEGAL_SOURCE_FILE = SourceFile.from("[MOCKED SOURCE STREAM]", "")

internal val ILLEGAL_SOURCE_RANGE = SourceRange(SourcePosition(ILLEGAL_SOURCE_FILE, 0), 0)

/**
 * **ONLY** use for testing in the DSL below. It will assign illegal source positions to AST nodes, that must be ignored.
 * ASTs generated by this must not be given into code analysis or other subsequent compilation phases. They can only be
 * used for comparison to generated ASTs.
 */
internal fun <T> T.wrapMockValid(): Parsed.Valid<T> {
    return Parsed.Valid(ILLEGAL_SOURCE_RANGE, this)
}

class ClassDeclarationDsl(res: MutableList<Parsed<AST.ClassDeclaration>> = mutableListOf()) :
    AstDsl<Parsed<AST.ClassDeclaration>>(res) {
    fun clazz(name: String, block: ClassMemberDsl.() -> Unit) {
        val members = ClassMemberDsl().also { it.block() }
        this.res.add(
            AST.ClassDeclaration(
                name.toSymbol().wrapMockValid(),
                members.res
            ).wrapMockValid()
        )
    }
}

class ClassMemberDsl(res: MutableList<Parsed<AST.ClassMember>> = mutableListOf()) :
    AstDsl<Parsed<AST.ClassMember>>(res) {

    fun param(name: String, type: AST.Type) = AST.Parameter(name.toSymbol().wrapMockValid(), type.wrapMockValid())

    fun field(name: String, type: AST.Type) {
        this.res.add(AST.Field(name.toSymbol().wrapMockValid(), type.wrapMockValid()).wrapMockValid())
    }

    fun mainMethod(
        name: String,
        returnType: AST.Type,
        vararg parameters: AST.Parameter,
        throws: String? = null,
        block: BlockStatementDsl.() -> Unit
    ) {

        this.res.add(
            AST.MainMethod(
                name.toSymbol().wrapMockValid(),
                returnType.wrapMockValid(),
                parameters.toList().map { it.wrapMockValid() },
                AST.Block(BlockStatementDsl().also(block).res, Unit.wrapMockValid(), Unit.wrapMockValid())
                    .wrapMockValid(),
                throws?.toSymbol()?.wrapMockValid()
            ).wrapMockValid()
        )
    }

    fun method(
        name: String,
        returnType: AST.Type,
        vararg parameters: AST.Parameter,
        throws: String? = null,
        block: BlockStatementDsl.() -> Unit
    ) {
        this.res.add(
            AST.Method(
                name.toSymbol().wrapMockValid(),
                returnType.wrapMockValid(),
                parameters.toList().map { it.wrapMockValid() },
                AST.Block(BlockStatementDsl().also(block).res, Unit.wrapMockValid(), Unit.wrapMockValid())
                    .wrapMockValid(),
                throws?.toSymbol()?.wrapMockValid()
            ).wrapMockValid()
        )
    }
}

object ExprDsl {
    fun <T> literal(v: T) = when (v) {
        is Boolean -> AST.LiteralExpression.Boolean(v)
        null -> AST.LiteralExpression.Null()
        "this" -> AST.LiteralExpression.This()
        is String -> {
            check(v.matches("-?(0|[1-9]\\d*)".toRegex()))
            if (v.startsWith("-")) {
                AST.LiteralExpression.Integer(v.substring(1), true)
            } else {
                AST.LiteralExpression.Integer(v, false)
            }
        }
        else -> throw IllegalArgumentException("unknown literal type: $v")
    }

    fun binOp(
        op: AST.BinaryExpression.Operation,
        left: ExprDsl.() -> AST.Expression,
        right: ExprDsl.() -> AST.Expression
    ) =
        AST.BinaryExpression(ExprDsl.left().wrapMockValid(), ExprDsl.right().wrapMockValid(), op)

    fun unOp(
        op: AST.UnaryExpression.Operation,
        expr: ExprDsl.() -> AST.Expression,
    ) =
        AST.UnaryExpression(ExprDsl.expr().wrapMockValid(), op)

    fun ident(name: String) = AST.IdentifierExpression(name.toSymbol().wrapMockValid())

    fun arrayAccess(
        target: ExprDsl.() -> AST.Expression,
        index: ExprDsl.() -> AST.Expression
    ) = AST.ArrayAccessExpression(ExprDsl.target().wrapMockValid(), ExprDsl.index().wrapMockValid())

    fun fieldAccess(
        left: ExprDsl.() -> AST.Expression,
        field: String
    ) = AST.FieldAccessExpression(ExprDsl.left().wrapMockValid(), field.toSymbol().wrapMockValid())

    fun newArrayOf(
        type: AST.Type.Array,
        length: ExprDsl.() -> AST.Expression
    ) = AST.NewArrayExpression(type.wrapMockValid(), ExprDsl.length().wrapMockValid())

    fun invoke(
        target: ExprDsl.() -> AST.Expression,
        method: String,
        vararg parameters: ExprDsl.() -> AST.Expression,
    ) = AST.MethodInvocationExpression(ExprDsl.target().wrapMockValid(), method.toSymbol().wrapMockValid(), parameters.map { ExprDsl.it().wrapMockValid() })
}

class BlockStatementDsl(val res: MutableList<Parsed<AST.BlockStatement>> = mutableListOf()) {
    fun localDeclaration(
        name: String,
        type: AST.Type,
        initializer: (ExprDsl.() -> AST.Expression)? = null
    ) {
        res.add(
            AST.LocalVariableDeclarationStatement(
                name.toSymbol().wrapMockValid(), type.wrapMockValid(),
                if (initializer != null) {
                    ExprDsl.initializer().wrapMockValid()
                } else null
            ).wrapMockValid()
        )
    }

    fun emptyStatement() = res.add(AST.Block(listOf(), Unit.wrapMockValid(), Unit.wrapMockValid()).wrapMockValid())
    fun block(b: BlockStatementDsl.() -> Unit) {
        res.add(AST.Block(BlockStatementDsl().also(b).res, Unit.wrapMockValid(), Unit.wrapMockValid()).wrapMockValid())
    }

    fun expressionStatement(expr: ExprDsl.() -> AST.Expression) {
        res.add(AST.ExpressionStatement(ExprDsl.expr().wrapMockValid()).wrapMockValid())
    }

    fun ifStmt(
        cond: ExprDsl.() -> AST.Expression,
        trueStmt: StatementDsl.() -> AST.Statement,
        falseStmt: (StatementDsl.() -> AST.Statement)? = null
    ) = res.add(StatementDsl.ifStmt(cond, trueStmt, falseStmt).wrapMockValid())
}

object StatementDsl {
    fun ifStmt(
        cond: ExprDsl.() -> AST.Expression,
        trueStmt: StatementDsl.() -> AST.Statement,
        falseStmt: (StatementDsl.() -> AST.Statement)? = null
    ) = AST.IfStatement(
        ExprDsl.cond().wrapMockValid(),
        StatementDsl.trueStmt().wrapMockValid(),
        falseStmt?.let { StatementDsl.it().wrapMockValid() }
    )
}

class StatementsDsl(val res: MutableList<Parsed<AST.Statement>> = mutableListOf()) {
    fun block(b: StatementsDsl.() -> Unit) {
        res.add(AST.Block(StatementsDsl().also(b).res, Unit.wrapMockValid(), Unit.wrapMockValid()).wrapMockValid())
    }

    fun ifStmt(
        cond: ExprDsl.() -> AST.Expression,
        trueStmt: StatementDsl.() -> AST.Statement,
        falseStmt: (StatementDsl.() -> AST.Statement)? = null
    ) = res.add(StatementDsl.ifStmt(cond, trueStmt, falseStmt).wrapMockValid())
}

fun astOf(block: ClassDeclarationDsl.() -> Unit) =
    ClassDeclarationDsl().also(block).res

fun expressionOf(block: ExprDsl.() -> AST.Expression) = ExprDsl.block().wrapMockValid()
