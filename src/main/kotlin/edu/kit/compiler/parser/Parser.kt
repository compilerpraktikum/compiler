package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.ast.AST
import edu.kit.compiler.ast.Type
import edu.kit.compiler.ast.toASTOperation
import edu.kit.compiler.lex.Lexer
import edu.kit.compiler.lex.SourceFile
import edu.kit.compiler.lex.SourceRange
import edu.kit.compiler.lex.Symbol
import edu.kit.compiler.wrapper.Parsed
import edu.kit.compiler.wrapper.ParsedArrayType
import edu.kit.compiler.wrapper.ParsedBlock
import edu.kit.compiler.wrapper.ParsedBlockStatement
import edu.kit.compiler.wrapper.ParsedClassDeclaration
import edu.kit.compiler.wrapper.ParsedClassMember
import edu.kit.compiler.wrapper.ParsedExpression
import edu.kit.compiler.wrapper.ParsedField
import edu.kit.compiler.wrapper.ParsedLocalVariableDeclaration
import edu.kit.compiler.wrapper.ParsedMainMethod
import edu.kit.compiler.wrapper.ParsedMethod
import edu.kit.compiler.wrapper.ParsedParameter
import edu.kit.compiler.wrapper.ParsedProgram
import edu.kit.compiler.wrapper.ParsedStatement
import edu.kit.compiler.wrapper.ParsedType
import edu.kit.compiler.wrapper.fmapParsed
import edu.kit.compiler.wrapper.into
import edu.kit.compiler.wrapper.wrappers.Lenient
import edu.kit.compiler.wrapper.wrappers.annotation
import edu.kit.compiler.wrapper.wrappers.compose
import edu.kit.compiler.wrapper.wrappers.into
import edu.kit.compiler.wrapper.wrappers.mapValue
import edu.kit.compiler.wrapper.wrappers.markErroneous
import edu.kit.compiler.wrapper.wrappers.positioned
import edu.kit.compiler.wrapper.wrappers.wrapErroneous
import edu.kit.compiler.wrapper.wrappers.wrapValid
import java.util.Optional

private val Token.isRelevantForSyntax
    get() = when (this) {
        is Token.Whitespace, is Token.Comment, is Token.ErrorToken -> false
        else -> true
    }

/**
 * Parser that consumes a token sequence generated by [Lexer.tokens] and generates an abstract syntax tree from it.
 *
 * @param tokens [Sequence] of [tokens][Token]
 * @param sourceFile input wrapper that handles error reporting
 */
@ExperimentalStdlibApi
class Parser(sourceFile: SourceFile, tokens: Sequence<Token>) :
    AbstractParser(tokens.filter(Token::isRelevantForSyntax), sourceFile) {

    /**
     * Parse the lexer stream into an AST.
     */
    override fun parse(): Parsed<ParsedProgram> {
        val classDeclarations = parseClassDeclarations(anchorSetOf(Token.Eof()).intoUnion())
        val eof = expect<Token.Eof>(anchorSetOf().intoUnion()) { "expected end of file" }

        return if (eof.value != null)
            AST.Program(classDeclarations).wrapValid().positioned(
                if (classDeclarations.isEmpty()) {
                    eof.value.range
                } else {
                    classDeclarations.get(0).unCompose.into().annotation.extend(eof.value.range)
                }
            ).compose()
        else
            AST.Program(classDeclarations).wrapErroneous().positioned(
                if (classDeclarations.isEmpty()) {
                    peek().range
                } else {
                    classDeclarations.get(0).unCompose.into().annotation
                }
            ).compose()
    }

    private fun parsePrimaryExpression(anc: AnchorUnion): Parsed<ParsedExpression> {
        return when (val peekedToken = peek()) {
            is Token.Literal -> {
                next()
                AST.LiteralExpression(peekedToken.value).wrapValid().positioned(peekedToken.range).compose()
            }
            is Token.Operator -> {
                if (peekedToken.type == Token.Operator.Type.LParen) {
                    next()
                    val innerExpr = parseExpression(1, anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    expectOperator(Token.Operator.Type.RParen, anc) { "expected closing parenthesis." }
                    innerExpr
                } else {
                    reportError(
                        peekedToken,
                        "illegal token `${peekedToken.debugRepr}`, expected expression",
                    )
                    recover(anc)
                    Lenient.Error(null).positioned(peekedToken.range).compose()
                }
            }
            is Token.Identifier -> {
                val reference = next() as Token.Identifier

                val maybeLParent = peek(0)
                if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                    next()
                    val arguments = parseArguments(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    val rParen = expectOperator(Token.Operator.Type.RParen, anc) { "expected `)`" }

                    if (rParen.value != null) {
                        AST.MethodInvocationExpression(null, reference.name, arguments).wrapValid()
                            .positioned(peekedToken.range).compose()
                    } else {
                        AST.MethodInvocationExpression(null, reference.name, arguments).wrapErroneous()
                            .positioned(peekedToken.range).compose()
                    }
                } else {
                    AST.IdentifierExpression(reference.name).wrapValid().positioned(peekedToken.range).compose()
                }
            }
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Null -> {
                        next()
                        AST.LiteralExpression("null").wrapValid().positioned(peekedToken.range).compose()
                    }
                    Token.Keyword.Type.False -> {
                        next()
                        AST.LiteralExpression(false).wrapValid().positioned(peekedToken.range).compose()
                    }
                    Token.Keyword.Type.True -> {
                        next()
                        AST.LiteralExpression(true).wrapValid().positioned(peekedToken.range).compose()
                    }
                    Token.Keyword.Type.This -> {
                        next()
                        AST.LiteralExpression("this").wrapValid().positioned(peekedToken.range).compose()
                    }
                    Token.Keyword.Type.New -> {
                        next()
                        parseNewObjectArrayExpression(anc)
                    }
                    else -> {
                        reportError(
                            peekedToken,
                            "illegal token `${peekedToken.debugRepr}`. expected expression",
                        )
                        recover(anc)
                        return Lenient.Error(null).positioned(peekedToken.range).compose()
                    }
                }
            }
            else -> {
                reportError(
                    peekedToken,
                    "illegal token `${peekedToken.debugRepr}`. expected expression",
                )
                recover(anc)
                return Lenient.Error(null).positioned(peekedToken.range).compose()
            }
        }
    }

    /**
     *
     */
    private fun parseNewObjectArrayExpression(anc: AnchorUnion): Parsed<ParsedExpression> {
        return when (val firstToken = peek()) {
            is Token.Keyword -> when (firstToken.type) {
                Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                    parseNewArrayExpression(anc)
                else -> {
                    reportError(firstToken, "illegal token `${firstToken.debugRepr}`. expected type")
                    recover(anc)
                    return Lenient.Error(null).positioned(firstToken.range).compose()
                }
            }
            is Token.Identifier -> {
                // k=2
                when (val secondToken = peek(1)) {
                    is Token.Operator -> {
                        when (secondToken.type) {
                            Token.Operator.Type.LParen -> parseNewObjectExpression(anc)
                            Token.Operator.Type.LeftBracket -> parseNewArrayExpression(anc)
                            else -> {
                                reportError(
                                    secondToken,
                                    "illegal token `${secondToken.debugRepr}`. expected constructor call or array type",
                                )
                                recover(anc)
                                return Lenient.Error(null).positioned(firstToken.range.extend(secondToken.range))
                                    .compose()
                            }
                        }
                    }
                    else -> {
                        reportError(
                            secondToken,
                            "illegal token `${secondToken.debugRepr}`. expected constructor call or array type",
                        )
                        recover(anc)
                        return Lenient.Error(null).positioned(firstToken.range.extend(secondToken.range)).compose()
                    }
                }
            }
            else -> {
                reportError(firstToken, "illegal token `${firstToken.debugRepr}`. expected type")
                recover(anc)
                return Lenient.Error(null).positioned(firstToken.range).compose()
            }
        }
    }

    private fun parseNewObjectExpression(anc: AnchorUnion): Parsed<ParsedExpression> {
        val ident = next() as Token.Identifier
        next() // skip open parenthesis
        val rParen = expectOperator(Token.Operator.Type.RParen, anc) { "constructor calls must be empty. expected `)`" }

        return if (rParen.value != null) {
            AST.NewObjectExpression(ident.name).wrapValid().positioned(ident.range.extend(rParen.value.range)).compose()
        } else {
            AST.NewObjectExpression(ident.name).wrapErroneous().positioned(ident.range.extend(peek().range)).compose()
        }
    }

    private fun parseNewArrayExpression(anc: AnchorUnion): Parsed<ParsedExpression> {
        val basicType = parseBasicType(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LeftBracket),
                    Token.Operator(Token.Operator.Type.RightBracket)
                ) +
                FirstFollowUtils.firstSetExpression
        )

        /* We cannot assume that a bracket follows, because in case of primitive arrays no lookahead has happened yet */
        expectOperator(
            Token.Operator.Type.LeftBracket,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                FirstFollowUtils.firstSetExpression
        ) { "expected `[` denoting an array type" }

        val indexExpression = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)))

        val rBracket = expectOperator(Token.Operator.Type.RightBracket, anc) { "expected `]`" }

        val arrayType = if (rBracket.value != null) {
            parseNewArrayExpressionTypeArrayRecurse(
                Type.Array.ArrayType(basicType).wrapValid().positioned(basicType.unCompose.annotation).compose(),
                anc
            )
        } else {
            parseNewArrayExpressionTypeArrayRecurse(
                Type.Array.ArrayType(basicType).wrapErroneous().positioned(basicType.unCompose.annotation).compose(),
                anc
            )
        }

        return AST.NewArrayExpression(arrayType, indexExpression).wrapValid()
            .positioned(basicType.unCompose.annotation.extend(arrayType.unCompose.into().annotation)).compose()
    }

    private fun parseNewArrayExpressionTypeArrayRecurse(
        basicType: Parsed<ParsedArrayType>,
        anc: AnchorUnion
    ): Parsed<ParsedArrayType> {
        val maybeAnotherLBracket = peek(0)

        return if (maybeAnotherLBracket !is Token.Eof) {
            // special case for NewArrayExpression in combination with ArrayAccess
            // (in "PostfixExpression -> PrimaryExpression (PostfixOp)*" Production)
            val maybeAnotherRBracket = peek(1)

            if (
                (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) &&
                (maybeAnotherRBracket is Token.Operator && maybeAnotherRBracket.type == Token.Operator.Type.RightBracket)
            ) {
                next()
                next()
                val elementType = parseNewArrayExpressionTypeArrayRecurse(basicType, anc).fmapParsed { it.wrapArray() }
                Type.Array.ArrayType(elementType)
                    .wrapValid().positioned(elementType.unCompose.annotation).compose()
            } else {
                basicType
            }
        } else {
            basicType
        }
    }

    private fun parseArguments(anc: AnchorUnion): List<Parsed<ParsedExpression>> {
        val arguments = mutableListOf<Parsed<ParsedExpression>>()
        var nextToken = peek()

        /*
         * Intervention: because the loop waits for a specific token to arise, it makes zero sense to recover to
         * tokens from anchor sets outside the loop. We will therefore replace the anchor set with one that
         * contains only tokens from the loop condition, to prevent the parser from spinning on miss-placed tokens
         * that are in the anchor set.
         */
        val loopAnchor = anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Eof())
        while (nextToken !in loopAnchor) {
            if (arguments.isNotEmpty()) {
                expectOperator(
                    Token.Operator.Type.Comma,
                    loopAnchor +
                        FirstFollowUtils.firstSetExpression +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RParen))
                ) { "arguments must be comma-separated" }
            }
            arguments += parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
            nextToken = peek()
        }
        return arguments
    }

    private fun parsePostfixExpression(anc: AnchorUnion): Parsed<ParsedExpression> {
        val primaryExpression = parsePrimaryExpression(anc + FirstFollowUtils.firstSetPostfixOp)

        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot,
                    Token.Operator.Type.LeftBracket -> parsePostfixOp(
                        primaryExpression,
                        anc + FirstFollowUtils.firstSetPostfixOp
                    )
                    else -> return primaryExpression
                }
            else -> return primaryExpression
        }
    }

    private fun parsePostfixOp(
        target: Parsed<ParsedExpression>,
        anc: AnchorUnion
    ): Parsed<ParsedExpression> {
        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot -> {
                        next()

                        val ident = expectIdentifier(
                            anc +
                                anchorSetOf(
                                    Token.Operator(Token.Operator.Type.LParen),
                                    Token.Operator(Token.Operator.Type.RParen),
                                ) +
                                FirstFollowUtils.firstSetArguments +
                                FirstFollowUtils.firstSetPostfixOp
                        ) { "expected member identifier" }

                        val maybeLParent = peek()
                        if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                            next()

                            val arguments = parseArguments(
                                anc +
                                    anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                                    FirstFollowUtils.firstSetPostfixOp
                            )

                            expectOperator(
                                Token.Operator.Type.RParen,
                                anc + FirstFollowUtils.firstSetPostfixOp,
                            ) { "expected `)`" }

                            if (ident.value != null) {
                                parsePostfixOp(
                                    AST.MethodInvocationExpression(target, ident.value.name, arguments).wrapValid()
                                        .positioned(firstPeekedToken.range.extend(ident.value.range)).compose(),
                                    anc
                                )
                            } else {
                                parsePostfixOp(
                                    AST.MethodInvocationExpression(target, Token.Identifier.Placeholder.name, arguments)
                                        .wrapErroneous().positioned(firstPeekedToken.range).compose(),
                                    anc
                                )
                            }
                        } else {
                            if (ident.value != null) {
                                parsePostfixOp(
                                    AST.FieldAccessExpression(target, ident.value.name).wrapValid()
                                        .positioned(firstPeekedToken.range.extend(ident.value.range)).compose(),
                                    anc
                                )
                            } else {
                                parsePostfixOp(
                                    AST.FieldAccessExpression(target, Token.Identifier.Placeholder.name)
                                        .wrapErroneous().positioned(firstPeekedToken.range).compose(),
                                    anc
                                )
                            }
                        }
                        // k=3 because lazy. Maybe change this if needed later on
                    }
                    Token.Operator.Type.LeftBracket -> {
                        next()

                        val index = parseExpression(
                            anc = anc +
                                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                                FirstFollowUtils.firstSetPostfixOp
                        )

                        val rBracket = expectOperator(
                            Token.Operator.Type.RightBracket,
                            anc + FirstFollowUtils.firstSetPostfixOp
                        ) { "expected `]`" }

                        if (rBracket.value != null) {
                            parsePostfixOp(
                                AST.ArrayAccessExpression(target, index).wrapValid()
                                    .positioned(firstPeekedToken.range.extend(rBracket.annotation)).compose(),
                                anc
                            )
                        } else {
                            parsePostfixOp(
                                AST.ArrayAccessExpression(target, index).wrapErroneous()
                                    .positioned(firstPeekedToken.range.extend(index.unCompose.into().annotation))
                                    .compose(),
                                anc
                            )
                        }
                    }
                    else -> target
                }
            else -> target
        }
    }

    private fun parseUnaryExpression(anc: AnchorUnion): Parsed<ParsedExpression> {
        return when (val peeked = peek()) {
            is Token.Operator ->
                when (peeked.type) {
                    Token.Operator.Type.Not -> {
                        next()

                        AST.UnaryExpression(
                            parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators),
                            AST.UnaryExpression.Operation.NOT
                        ).wrapValid().positioned(peeked.range).compose()
                    }
                    Token.Operator.Type.Minus -> {
                        next()

                        AST.UnaryExpression(
                            parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators),
                            AST.UnaryExpression.Operation.MINUS
                        ).wrapValid().positioned(peeked.range).compose()
                    }
                    else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
                }
            else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
        }
    }

    internal fun parseExpression(
        minPrecedence: Int = 1,
        anc: AnchorUnion
    ): Parsed<ParsedExpression> {
        var result = parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators)
        var currentToken = peek()

        while (
            currentToken is Token.Operator &&
            (currentToken.type.toASTOperation()?.precedence?.let { it >= minPrecedence } == true)
        ) {
            val op = currentToken.type.toASTOperation()!!

            next()

            val rhs = parseExpression(
                when (op.associativity) {
                    AST.BinaryExpression.Operation.Associativity.LEFT -> op.precedence + 1
                    else -> op.precedence
                },
                anc + FirstFollowUtils.allExpressionOperators
            )
            result = AST.BinaryExpression(result, rhs, op).wrapValid()
                .positioned(result.unCompose.into().annotation.extend(rhs.unCompose.into().annotation)).compose()
            currentToken = peek()
        }
        return result
    }

    internal fun parseClassDeclarations(anc: AnchorUnion): List<Parsed<ParsedClassDeclaration>> {
        return buildList {
            while (peek(0) !is Token.Eof) {
                val peeked = peek()
                // manual intervention: we read away one visibility modifier if present. Those are illegal here, but we
                // avoid many follow-up errors if we do that. It isn't totally dumb, considering java allows them
                var illegalVisibilityModifier = false
                if (peeked in FirstFollowUtils.visibilityTokens) {
                    reportError(next(), "classes must not have visibility modifiers")
                    illegalVisibilityModifier = true
                }

                val classKeyword = expectKeyword(
                    Token.Keyword.Type.Class,
                    anc +
                        anchorSetOf(
                            Token.Identifier.Placeholder,
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                ) { "expected class declaration" }

                val ident = expect<Token.Identifier>(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                            Token.Eof()
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                ) { "expected class name" }

                val lBrace = expectOperator(
                    Token.Operator.Type.LeftBrace,
                    anc +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                        FirstFollowUtils.firstSetClassMembers
                ) {
                    "missing opening brace"
                }

                val classMembers = parseClassMembers(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)))

                val rBrace = expectOperator(Token.Operator.Type.RightBrace, anc) {
                    "missing closing brace"
                }

                if (classKeyword.value != null && ident.value != null && lBrace.value != null && rBrace.value != null && !illegalVisibilityModifier) {
                    AST.ClassDeclaration(ident.value.name, classMembers).wrapValid()
                } else {
                    AST.ClassDeclaration(ident.value?.name ?: (Token.Identifier.Placeholder).name, classMembers)
                        .wrapErroneous()
                }.positioned(classKeyword.annotation.extend(lBrace.annotation)).compose()
                    .let { add(it) }
            }
        }
    }

    private fun parseClassMembers(anc: AnchorUnion): List<Parsed<ParsedClassMember>> {
        return buildList {
            var peeked = peek(0)

            while (true) {
                // read class members while we find visibility tokens. Most of them won't be accepted, but it will
                // improve error messages
                while (peeked in FirstFollowUtils.visibilityTokens) {
                    add(parseClassMember(anc + FirstFollowUtils.firstSetClassMember))
                    peeked = peek(0)
                }

                /*
                 * Manual intervention: Strictly following anchor sets and SLL parsing, we would expect the end of the
                 * class file here, because we did not encounter another `public`. But if we do not see an `}`, we assume
                 * that all following tokens are miss-placed and recover until the next `class` definition starts. This
                 * is stupid however, because this means that one missing `public` will result in all following members
                 * being skipped.
                 * So instead we check if the peeked token is a valid start of a class member after a `public`, and
                 * if so, we will parse it anyway (resulting in an error because `public` is missing, but good recovery
                 * after that). Then, we will try and parse more members starting at `public` again. However, if the
                 * peeked token is not valid even after a `public` token, we will recover towards the next `public` token
                 * (or the end of class as usual).
                 */

                if (peeked !in anc.provide() /* there are only more members if we aren't in follow(classmembers) */) {
                    val semiLegalAnchorSet =
                        FirstFollowUtils.firstSetFieldMethodPrefix + FirstFollowUtils.firstSetMainMethodPrefix
                    if (peeked in semiLegalAnchorSet.provide()) {
                        // this will be illegal, but we get better error reporting from it
                        add(parseClassMember(anc + FirstFollowUtils.visibilityTokens))
                    } else {
                        reportError(peeked, "expected class member definition")
                        recover(anc + FirstFollowUtils.visibilityTokens)
                    }
                    peeked = peek(0)
                } else {
                    break
                }
            }
        }
    }

    private fun parseClassMember(anc: AnchorUnion): Parsed<ParsedClassMember> {
        val publicKeyword = expectKeyword(
            Token.Keyword.Type.Public,
            anc + anchorSetOf(
                Token.Keyword(Token.Keyword.Type.Static),
                Token.Keyword(Token.Keyword.Type.Int),
                Token.Keyword(Token.Keyword.Type.Boolean),
                Token.Keyword(Token.Keyword.Type.Void),
                Token.Identifier.Placeholder
            )
        ) { "class members must be public" }

        val childNode = when (val token = peek(0)) {
            is Token.Keyword -> {
                when (token.type) {
                    Token.Keyword.Type.Static -> parseMainMethod(anc)
                    Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                        parseFieldMethodPrefix(anc)
                    else -> {
                        reportError(token, "expected `static` or (return) type identifier")
                        recover(anc)
                        return Lenient.Error(null).positioned(token.range).compose()
                    }
                }
            }
            is Token.Identifier -> {
                parseFieldMethodPrefix(anc)
            }
            else -> {
                reportError(token, "expected field or method declaration")
                recover(anc)
                return Lenient.Error(null).positioned(token.range).compose()
            }
        }

        return if (publicKeyword.value != null) {
            childNode.into()
        } else {
            childNode.unCompose.mapValue { it.into().markErroneous() }.compose()
        }
    }

    private fun parseMainMethod(anc: AnchorUnion): Parsed<ParsedMainMethod> {
        val staticKeyword = expectKeyword(
            Token.Keyword.Type.Static,
            anc +
                anchorSetOf(
                    Token.Keyword(Token.Keyword.Type.Void),
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "main method must be `static`" }

        val voidKeywordLocation = peek().range
        val voidKeyword = expectKeyword(
            Token.Keyword.Type.Void,
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "main method must return `void`" }

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "expected function name `main`" }

        val leftParen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "missing opening parenthesis" }

        // manually check if a parameter can be parsed before trying, so we can report a more sensible error message
        // than `expected type`
        val peeked = peek()
        val parameter: Parsed<ParsedParameter> = if (peeked in FirstFollowUtils.firstSetParameter) {
            parseParameter(
                anc +
                    anchorSetOf(
                        Token.Operator(Token.Operator.Type.RParen),
                        Token.Keyword(Token.Keyword.Type.Throws),
                    ) +
                    FirstFollowUtils.firstSetBlock
            )
        } else {
            reportError(peeked, "expected one parameter of type `String[]`")
            recover(
                anc +
                    anchorSetOf(
                        Token.Operator(Token.Operator.Type.RParen),
                        Token.Keyword(Token.Keyword.Type.Throws),
                    ) +
                    FirstFollowUtils.firstSetBlock
            )
            Lenient.Error(null).positioned(peeked.range /* TODO check is source range is correct*/).compose()
        }

        val rightParen = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        ) {
            if (peek() in FirstFollowUtils.firstSetParameter) {
                "main method may only have one parameter of type `String[]`"
            } else {
                "expected closing parenthesis"
            }
        }

        val maybeThrowsToken = peek(0)
        val throwsException =
            if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
                parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
            } else {
                null
            }

        val block = parseBlock(anc)

        return if (staticKeyword.value != null && voidKeyword.value != null && ident.value != null && leftParen.value != null &&
            rightParen.value != null && throwsException?.isPresent != false
        ) {
            AST.MainMethod(
                ident.value.name,
                Type.Void.wrapValid().positioned(voidKeywordLocation).compose(),
                listOf(parameter),
                block.into(),
                throwsException?.get()
            ).wrapValid()
        } else {
            AST.MainMethod(
                ident.value?.name ?: Token.Identifier.Placeholder.name,
                Type.Void.wrapValid().positioned(voidKeywordLocation).compose(),
                listOf(parameter),
                block,
                throwsException?.orElse(null)
            ).wrapErroneous()
        }.positioned(ident.annotation.extend(block.unCompose.annotation))
            .compose()
    }

    private fun parseFieldMethodPrefix(anc: AnchorUnion): Parsed<ParsedClassMember> {
        val type = parseType(
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        )

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        ) { "expected identifier" }

        return when (val fieldMethodRestToken = peek(0)) {
            is Token.Operator -> {
                when (fieldMethodRestToken.type) {
                    Token.Operator.Type.Semicolon -> parseField(Optional.ofNullable(ident.value), type)
                    Token.Operator.Type.LParen -> parseMethod(Optional.ofNullable(ident.value), type, anc)
                    else -> {
                        reportError(
                            fieldMethodRestToken,
                            "illegal class member declaration. expected either a method declaration or `;`",
                        )
                        recover(anc)
                        Lenient.Error(null).positioned(fieldMethodRestToken.range).compose()
                    }
                }
            }
            else -> {
                reportError(
                    fieldMethodRestToken,
                    "illegal class member declaration. expected either `;` or `(`.",
                )
                recover(anc)
                Lenient.Error(null).positioned(fieldMethodRestToken.range).compose()
            }
        }
    }

    private fun parseField(
        ident: Optional<Token.Identifier>,
        type: Parsed<ParsedType>
    ): Parsed<ParsedField> {
        next()

        return if (ident.isPresent) {
            AST.Field(
                ident.get().name,
                type
            ).wrapValid().positioned(type.unCompose.annotation.extend(ident.get().range)).compose()
        } else {
            AST.Field(
                ident.orElse(Token.Identifier.Placeholder).name,
                type
            ).wrapErroneous().positioned(type.unCompose.into().annotation).compose()
        }
    }

    private fun parseMethod(
        ident: Optional<Token.Identifier>,
        type: Parsed<ParsedType>,
        anc: AnchorUnion
    ): Parsed<ParsedMethod> {
        next()

        val maybeRParenToken = peek(0)
        val parameters =
            if (!(maybeRParenToken is Token.Operator && maybeRParenToken.type == Token.Operator.Type.RParen)) {
                parseParameters(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.RParen),
                            Token.Keyword(Token.Keyword.Type.Throws)
                        ) +
                        FirstFollowUtils.firstSetBlock
                )
            } else emptyList()

        val closingParenthesis = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        ) { "expected `)`" }

        val maybeThrowsToken = peek(0)
        val throwsException =
            if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
                parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
            } else {
                null
            }

        val block = parseBlock(anc)

        return if (ident.isPresent && closingParenthesis.value != null && throwsException?.isPresent != false) {
            AST.Method(
                ident.get().name,
                type,
                parameters,
                block,
                throwsException?.get()
            ).wrapValid()
        } else {
            AST.Method(
                ident.orElse(Token.Identifier.Placeholder).name,
                type,
                parameters,
                block,
                throwsException?.orElse(null)
            ).wrapErroneous()
        }.positioned(ident.get().range.extend(block.unCompose.annotation)).compose()
    }

    internal fun parseBlock(anc: AnchorUnion): Parsed<ParsedBlock> {
        val openingBrace = expectOperator(
            Token.Operator.Type.LeftBrace,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                FirstFollowUtils.firstSetBlockStatement
        ) { "expected opening brace" }

        val maybeRightBrace = peek(0)

        val resultBlock = AST.Block(
            if (!(maybeRightBrace is Token.Operator && maybeRightBrace.type == Token.Operator.Type.RightBrace)) {
                parseBlockStatements()
            } else {
                emptyList()
            }
        )

        val closingBrace = expectOperator(Token.Operator.Type.RightBrace, anc) { "expected closing brace" }

        return if (openingBrace.value != null && closingBrace.value != null) {
            resultBlock.wrapValid()
        } else {
            resultBlock.wrapErroneous()
        }.positioned(openingBrace.annotation.extend(closingBrace.annotation)).compose()
    }

    private fun parseBlockStatements(): List<Parsed<ParsedBlockStatement>> {
        // at least one should exist at this point.
        return buildList {
            var peeked = peek(0)

            /*
             * Intervention: because the loop waits for a specific token to arise, it makes zero sense to recover to
             * tokens from anchor sets outside the loop. We will therefore replace the anchor set with one that
             * contains only tokens from the loop condition, to prevent the parser from spinning on miss-placed tokens
             * that are in the anchor set.
             */
            val loopAnchor = anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace), Token.Eof())
            while (peeked !in loopAnchor) {
                add(parseBlockStatement(loopAnchor + FirstFollowUtils.firstSetBlockStatement))
                peeked = peek(0)
            }
        }
    }

    private fun parseBlockStatement(anc: AnchorUnion): Parsed<ParsedBlockStatement> {
        return when (val firstToken = peek(0)) {
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If,
                    Token.Keyword.Type.While,
                    Token.Keyword.Type.Return,
                    Token.Keyword.Type.Null,
                    Token.Keyword.Type.False,
                    Token.Keyword.Type.True,
                    Token.Keyword.Type.This,
                    Token.Keyword.Type.New -> parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }

                    Token.Keyword.Type.Int,
                    Token.Keyword.Type.Boolean,
                    Token.Keyword.Type.Void -> parseLocalVariableDeclarationStatement(anc)

                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null).positioned(firstToken.range).compose()
                    }
                }
            }
            is Token.Literal -> parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace,
                    Token.Operator.Type.Semicolon,
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }

                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null).positioned(firstToken.range).compose()
                    }
                }
            }
            is Token.Identifier -> {
                // Lookahead = 3 needed, here!
                when (val secondToken = peek(1)) {
                    is Token.Identifier -> parseLocalVariableDeclarationStatement(anc)
                    is Token.Operator -> {
                        if (secondToken.type == Token.Operator.Type.LeftBracket) {
                            when (val thirdToken = peek(2)) {
                                is Token.Operator -> {
                                    if (thirdToken.type == Token.Operator.Type.RightBracket) {
                                        parseLocalVariableDeclarationStatement(anc)
                                    } else {
                                        parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }
                                    }
                                }
                                else -> parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }
                            }
                        } else {
                            parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }
                        }
                    }
                    else -> parseStatement(anc).fmapParsed { AST.StmtWrapper(it) }
                }
            }
            else -> {
                reportError(
                    firstToken,
                    "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                )
                recover(anc)
                return Lenient.Error(null).positioned(firstToken.range).compose()
            }
        }
    }

    internal fun parseStatement(anc: AnchorUnion): Parsed<ParsedStatement> {
        return when (val firstToken = peek(0)) {
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace -> parseBlock(anc)
                    Token.Operator.Type.Semicolon -> parseEmptyStatement()
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseExpressionStatement(anc)
                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null).positioned(firstToken.range).compose()
                    }
                }
            }
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If -> parseIfStatement(anc)
                    Token.Keyword.Type.While -> parseWhileStatement(anc)
                    Token.Keyword.Type.Return -> parseReturnStatement(anc)
                    Token.Keyword.Type.Null -> parseExpressionStatement(anc)
                    Token.Keyword.Type.False -> parseExpressionStatement(anc)
                    Token.Keyword.Type.True -> parseExpressionStatement(anc)
                    Token.Keyword.Type.This -> parseExpressionStatement(anc)
                    Token.Keyword.Type.New -> parseExpressionStatement(anc)
                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null).positioned(firstToken.range).compose()
                    }
                }
            }
            is Token.Literal -> parseExpressionStatement(anc)
            is Token.Identifier -> parseExpressionStatement(anc)
            else -> {
                reportError(
                    firstToken,
                    "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                )
                recover(anc)
                return Lenient.Error(null).positioned(firstToken.range).compose()
            }
        }
    }

    private fun parseReturnStatement(anc: AnchorUnion): Parsed<ParsedStatement> {
        val returnToken = next()

        val maybeSemicolon = peek(0)
        var returnValue: Parsed<ParsedExpression>? = null
        if (!(maybeSemicolon is Token.Operator && maybeSemicolon.type == Token.Operator.Type.Semicolon)) {
            returnValue = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        }

        val semicolon = next()

        return AST.ReturnStatement(returnValue).wrapValid().positioned(returnToken.range.extend(semicolon.range))
            .compose()
    }

    private fun parseIfStatement(anc: AnchorUnion): Parsed<ParsedStatement> {
        val ifToken = next()

        val lparen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Else),
                ) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        ) { "missing `(`: if-conditions must be wrapped in parenthesis" }

        val condition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        )

        val rparen = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        ) { "missing `)`: if-conditions must be wrapped in parenthesis" }

        val trueStatement = parseStatement(anc + anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)))

        val maybeElseToken = peek(0)
        var falseStatement: Parsed<ParsedStatement>? = null
        if (maybeElseToken is Token.Keyword && maybeElseToken.type == Token.Keyword.Type.Else) {
            next()
            falseStatement = parseStatement(anc)
        }

        val range: SourceRange =
            ifToken.range.extend(falseStatement?.unCompose?.into()?.annotation ?: trueStatement.unCompose.into().annotation)

        return if (lparen.value != null && rparen.value != null) {
            AST.IfStatement(
                condition,
                trueStatement,
                falseStatement
            ).wrapValid()
        } else {
            AST.IfStatement(
                condition,
                trueStatement,
                falseStatement
            ).wrapErroneous()
        }.positioned(range).compose()
    }

    private fun parseWhileStatement(anc: AnchorUnion): Parsed<ParsedStatement> {
        val whileToken = next()

        val lparen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        ) { "missing `(`: loop-conditions must be wrapped in parenthesis" }

        val loopCondition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetStatement
        )

        val rparen = expectOperator(
            Token.Operator.Type.RParen,
            anc + FirstFollowUtils.firstSetStatement
        ) { "missing `)`: loop-conditions must be wrapped in parenthesis" }

        val loopBodyStatement = parseStatement(anc)

        return if (lparen.value != null && rparen.value != null) {
            AST.WhileStatement(loopCondition, loopBodyStatement).wrapValid()
                .positioned(whileToken.range.extend(loopBodyStatement.unCompose.into().annotation)).compose()
        } else {
            AST.WhileStatement(loopCondition, loopBodyStatement).wrapErroneous()
                .positioned(whileToken.range.extend(loopBodyStatement.unCompose.into().annotation)).compose()
        }
    }

    private fun parseEmptyStatement(): Parsed<ParsedStatement> {
        val token = next()
        return AST.emptyStatement.wrapValid().positioned(token.range).compose()
    }

    private fun parseLocalVariableDeclarationStatement(anc: AnchorUnion): Parsed<ParsedLocalVariableDeclaration> {
        val type = parseType(
            anc + anchorSetOf(
                Token.Identifier.Placeholder,
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        )

        val varName = expectIdentifier(
            anc + anchorSetOf(
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        ) { "expected identifier" }

        val initializer = when (val nextToken = peek()) {
            is Token.Operator ->
                if (nextToken.type == Token.Operator.Type.Assign) {
                    next()
                    parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
                } else {
                    null
                }
            else -> null
        }

        val semicolon = expectOperator(Token.Operator.Type.Semicolon, anc) { "expected `;`" }

        return if (varName.value != null && semicolon.value != null) {
            AST.LocalVariableDeclarationStatement(varName.value.name, type, initializer).wrapValid()
                .positioned(type.unCompose.into().annotation.extend(semicolon.value.range)).compose()
        } else {
            AST.LocalVariableDeclarationStatement(
                varName.value?.name ?: (Token.Identifier.Placeholder).name,
                type,
                initializer
            ).wrapErroneous().positioned(
                if (semicolon.value != null) {
                    type.unCompose.into().annotation.extend(semicolon.value.range)
                } else if (initializer != null) {
                    type.unCompose.into().annotation.extend(initializer.unCompose.into().annotation)
                } else {
                    type.unCompose.into().annotation
                }
            ).compose()
        }
    }

    private fun parseExpressionStatement(anc: AnchorUnion): Parsed<ParsedStatement> {
        val expr = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        val semicolon = expectOperator(Token.Operator.Type.Semicolon, anc) { "expected `;`" }

        return if (semicolon.value != null) {
            AST.ExpressionStatement(expr).wrapValid()
                .positioned(expr.unCompose.into().annotation.extend(semicolon.value.range)).compose()
        } else {
            AST.ExpressionStatement(expr).wrapErroneous().positioned(expr.unCompose.into().annotation).compose()
        }
    }

    private fun parseMethodRest(anc: AnchorUnion): Optional<Symbol> {
        next()

        return expectIdentifier(anc) { "missing identifier. `throws` requires an exception type" }.value
            .let { Optional.ofNullable(it) }
            .map { it.name }
    }

    private fun parseParameters(anc: AnchorUnion): List<Parsed<ParsedParameter>> {
        return buildList {
            add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))

            var maybeCommaToken = peek(0)
            while (maybeCommaToken is Token.Operator && maybeCommaToken.type == Token.Operator.Type.Comma) {
                next()
                add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))
                maybeCommaToken = peek(0)
            }
        }
    }

    private fun parseParameter(anc: AnchorUnion): Parsed<ParsedParameter> {
        val type = parseType(anc + anchorSetOf(Token.Identifier.Placeholder))
        val ident = expectIdentifier(anc) { "expected parameter name identifier" }

        return if (ident.value != null) {
            AST.Parameter(ident.value.name, type).wrapValid()
                .positioned(type.unCompose.into().annotation.extend(ident.value.range)).compose()
        } else {
            AST.Parameter(Token.Identifier.Placeholder.name, type).wrapErroneous()
                .positioned(type.unCompose.into().annotation).compose()
        }
    }

    private fun parseType(anc: AnchorUnion): Parsed<ParsedType> {
        val basicType = parseBasicType(anc + FirstFollowUtils.firstSetTypeArrayRecurse)

        val maybeLeftBracket = peek(0)
        if (maybeLeftBracket is Token.Operator && maybeLeftBracket.type == Token.Operator.Type.LeftBracket) {
            return parseTypeArrayRecurse(basicType, anc).fmapParsed { it.wrapArray() }
        }
        return basicType
    }

    private fun parseTypeArrayRecurse(
        basicType: Parsed<ParsedType>,
        anc: AnchorUnion
    ): Parsed<ParsedArrayType> {
        next()

        val rightBracket = expectOperator(
            Token.Operator.Type.RightBracket,
            anc + FirstFollowUtils.firstSetTypeArrayRecurse
        ) { "illegal array type expression. expected `]`" }

        val maybeAnotherLBracket = peek(0)
        return if (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) {
            if (rightBracket.value != null) {
                Type.Array.ArrayType(parseTypeArrayRecurse(basicType, anc).fmapParsed { it.wrapArray() }).wrapValid()
            } else {
                Type.Array.ArrayType(parseTypeArrayRecurse(basicType, anc).fmapParsed { it.wrapArray() })
                    .wrapErroneous()
            }
        } else {
            if (rightBracket.value != null)
                Type.Array.ArrayType(basicType).wrapValid()
            else
                Type.Array.ArrayType(basicType).wrapErroneous()
        }.positioned(basicType.unCompose.annotation /* TODO: find correct range*/).compose()
    }

    private fun parseBasicType(anc: AnchorUnion): Parsed<ParsedType> {
        return when (val peekedToken = peek()) {
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Int -> {
                        next()
                        Type.Integer.wrapValid().positioned(peekedToken.range).compose()
                    }
                    Token.Keyword.Type.Boolean -> {
                        next()
                        Type.Boolean.wrapValid().positioned(peekedToken.range).compose()
                    }
                    Token.Keyword.Type.Void -> {
                        next()
                        Type.Void.wrapValid().positioned(peekedToken.range).compose()
                    }
                    else -> {
                        reportError(peekedToken, "illegal token `${peekedToken.debugRepr}`. expected type")
                        recover(anc)
                        return Lenient.Error(null).positioned(peekedToken.range).compose()
                    }
                }
            }
            is Token.Identifier -> {
                val t = expectIdentifier(anc) { "expected type identifier" }
                return if (t.value != null) {
                    Type.Class(t.value.name).wrapValid().positioned(peekedToken.range).compose()
                } else {
                    Type.Class(Token.Identifier.Placeholder.name).wrapErroneous().positioned(peekedToken.range)
                        .compose()
                }
            }
            else -> {
                reportError(peekedToken, "illegal token `${peekedToken.debugRepr}`. expected type")
                recover(anc)
                return Lenient.Error(null).positioned(peekedToken.range).compose()
            }
        }
    }
}
