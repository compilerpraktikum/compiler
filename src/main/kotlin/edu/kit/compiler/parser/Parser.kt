package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.ast.AST
import edu.kit.compiler.ast.Type
import edu.kit.compiler.ast.toASTOperation
import edu.kit.compiler.lex.Lexer

private val Token.isRelevantForSyntax
    get() = !(this is Token.Whitespace || this is Token.Comment)

/**
 * Parser that consumes a token sequence generated by [Lexer.tokens] and generates an abstract syntax tree from it.
 *
 * @param[tokens] [sequence][Sequence] of [tokens][edu.kit.compiler.Token]
 */
@ExperimentalStdlibApi
class Parser(tokens: Sequence<Token>) : AbstractParser(tokens.filter(Token::isRelevantForSyntax)) {

    /**
     * Parse the lexer stream into an AST.
     */
    override fun parse(): AST.Program {
        val classDeclarations = parseClassDeclarations()
        expect<Token.Eof>()
        return AST.Program(classDeclarations)
    }

    private fun parsePrimaryExpression(): AST.Expression {
        return when (val peekedToken = peek()) {
            is Token.Literal -> {
                next()
                AST.LiteralExpression(peekedToken.value) // TODO we should further specify ""type""
            }
            is Token.Operator -> {
                if (peekedToken.type == Token.Operator.Type.LParen) {
                    next()
                    val innerExpr = parseExpression(1)
                    val tokenAfterParens = this.next()
                    if (tokenAfterParens is Token.Operator && tokenAfterParens.type == Token.Operator.Type.RParen) {
                        innerExpr
                    } else {
                        // TODO proper error handling
                        throw IllegalArgumentException("expected closing RPAREN")
                    }
                } else {
                    throw IllegalArgumentException("unexpected operator: $peekedToken")
                }
            }
            is Token.Identifier -> {
                val reference = expectIdentifier()

                val maybeLParent = peek(0)
                if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                    expectOperator(Token.Operator.Type.LParen)
                    val arguments = parseArguments()
                    expectOperator(Token.Operator.Type.RParen)

                    AST.MethodInvocationExpression(null, reference.name, arguments) // todo ist das richtig?
                } else AST.IdentifierExpression(reference.name)
            }
            is Token.Keyword -> {
                next()
                when (peekedToken.type) {
                    Token.Keyword.Type.Null -> AST.LiteralExpression("null") // TODO better ast stuff
                    Token.Keyword.Type.False ->
                        AST.LiteralExpression(false)
                    Token.Keyword.Type.True ->
                        AST.LiteralExpression(true)
                    Token.Keyword.Type.This ->
                        AST.LiteralExpression("this") // TODO better ast stuff
                    Token.Keyword.Type.New -> parseNewObjectArrayExpression()
                    else -> throw IllegalArgumentException("unexpected keyword ${peekedToken.type}")
                }
            }
            else -> throw IllegalArgumentException("unexpected token $peekedToken")
        }
    }

    private fun parseNewObjectArrayExpression(): AST.Expression {
        return when (val firstToken = peek()) {
            is Token.Keyword -> when (firstToken.type) {
                Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void -> parseNewArrayExpression()
                else -> panicMode()
            }
            is Token.Identifier -> {
                // k=2
                when (val secondToken = peek(1)) {
                    is Token.Operator -> {
                        when (secondToken.type) {
                            Token.Operator.Type.LParen -> parseNewObjectExpression()
                            Token.Operator.Type.LeftBracket -> parseNewArrayExpression()
                            else -> panicMode()
                        }
                    }
                    else -> panicMode()
                }
            }
            else -> panicMode()
        }
    }

    private fun parseNewObjectExpression(): AST.Expression {
        val ident = expectIdentifier()
        expectOperator(Token.Operator.Type.LParen)
        expectOperator(Token.Operator.Type.RParen)
        return AST.NewObjectExpression(ident.name)
    }

    private fun parseNewArrayExpression(): AST.Expression {
        val basicType = parseBasicType()
        expectOperator(Token.Operator.Type.LeftBracket)
        val indexExpression = parseExpression()
        expectOperator(Token.Operator.Type.RightBracket)
        val arrayType = parseNewArrayExpressionTypeArrayRecurse(Type.Array(basicType))
        return AST.NewArrayExpression(arrayType, indexExpression)
    }

    private fun parseNewArrayExpressionTypeArrayRecurse(basicType: Type.Array): Type.Array {
        val maybeAnotherLBracket = peek(0)
        val maybeAnotherRBracket =
            peek(1) // special case for NewArrayExpression in combination with ArrayAccess (in "PostfixExpression -> PrimaryExpression (PostfixOp)*" Production)
        return if (
            (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) &&
            (maybeAnotherRBracket is Token.Operator && maybeAnotherRBracket.type == Token.Operator.Type.RightBracket)
        ) {
            expectOperator(Token.Operator.Type.LeftBracket)
            expectOperator(Token.Operator.Type.RightBracket)
            Type.Array(parseNewArrayExpressionTypeArrayRecurse(basicType))
        } else {
            basicType
        }
    }

    private fun parseArguments(): List<AST.Expression> {
        val arguments = mutableListOf<AST.Expression>()
        var nextToken = peek()
        while (!(nextToken is Token.Operator && nextToken.type == Token.Operator.Type.RParen)) {
            if (arguments.isNotEmpty()) expectOperator(Token.Operator.Type.Comma)
            arguments += parseExpression()
            nextToken = peek()
        }
        return arguments
    }

    private fun parsePostfixExpression(): AST.Expression {
        val primaryExpression = parsePrimaryExpression()

        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot,
                    Token.Operator.Type.LeftBracket -> parsePostfixOp(primaryExpression)
                    else -> return primaryExpression
                }
            else -> return primaryExpression
        }
    }

    private fun parsePostfixOp(target: AST.Expression): AST.Expression {
        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot -> {
                        expectOperator(Token.Operator.Type.Dot)
                        val ident = expectIdentifier()
                        val maybeLParent = peek()
                        if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                            // methodInvocation todo recurse
                            expectOperator(Token.Operator.Type.LParen)
                            val arguments = parseArguments()
                            expectOperator(Token.Operator.Type.RParen)
                            parsePostfixOp(AST.MethodInvocationExpression(target, ident.name, arguments))
                        } else {
                            // fieldAccess todo recurse
                            parsePostfixOp(AST.FieldAccessExpression(target, ident.name))
                        }
                        // k=3 because lazy. Maybe change this if needed later on
                    }
                    Token.Operator.Type.LeftBracket -> {
                        expectOperator(Token.Operator.Type.LeftBracket)
                        val index = parseExpression()
                        expectOperator(Token.Operator.Type.RightBracket)
                        parsePostfixOp(AST.ArrayAccessExpression(target, index))
                    }
                    else -> target
                }
            else -> target
        }
    }

    private fun parseUnaryExpression(): AST.Expression {
        // todo not exhausting first(follow) of parsePrimary!)
        // TODO parsePostifixExpression instead of parsePrimaryExpression !
        return when (val peeked = peek()) {
            is Token.Operator ->
                when (peeked.type) {
                    Token.Operator.Type.Not -> {
                        expectOperator(Token.Operator.Type.Not)
                        AST.UnaryExpression(parseUnaryExpression(), AST.UnaryExpression.Operation.NOT)
                    }
                    Token.Operator.Type.Minus -> {
                        expectOperator(Token.Operator.Type.Minus)
                        AST.UnaryExpression(parseUnaryExpression(), AST.UnaryExpression.Operation.MINUS)
                    }
                    else -> parsePostfixExpression()
                }
            else -> parsePostfixExpression()
        }
    }

    internal fun parseExpression(minPrecedence: Int = 1): AST.Expression {
        var result = parseUnaryExpression()
        var currentToken = peek()

        while (
            currentToken is Token.Operator &&
            (currentToken.type.toASTOperation()?.precedence?.let { it >= minPrecedence } == true)
        ) {
            val op = currentToken.type.toASTOperation()!!

            next()

            val rhs = parseExpression(
                when (op.associativity) {
                    AST.BinaryExpression.Operation.Associativity.LEFT -> op.precedence + 1
                    else -> op.precedence
                }
            )
            result = AST.BinaryExpression(result, rhs, op)
            currentToken = peek()
        }
        return result
    }

    internal fun parseClassDeclarations(): List<AST.ClassDeclaration> {
        return buildList<AST.ClassDeclaration> {
            while (peek(0) != Token.Eof) {
                expectKeyword(Token.Keyword.Type.Class)
                val ident = expect<Token.Identifier>()
                expectOperator(Token.Operator.Type.LeftBrace)
                val classMembers = parseClassMembers()
                expectOperator(Token.Operator.Type.RightBrace)

                add(AST.ClassDeclaration(ident.name, classMembers))
                // val classNode constructClassNode(ident, classMembers)
            }
        }
    }

    private fun parseClassMembers(): List<AST.ClassMember> {
        return buildList<AST.ClassMember> {
            var peeked = peek(0)
            while (peeked is Token.Keyword && peeked.type == Token.Keyword.Type.Public) {
                add(parseClassMember())
                peeked = peek(0)
            }
        }
    }

    private fun parseClassMember(): AST.ClassMember {
        expectKeyword(Token.Keyword.Type.Public)
        val token = peek(0)

        return when (token) {
            is Token.Keyword -> {
                return when (token.type) {
                    Token.Keyword.Type.Static -> parseMainMethod()
                    Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                        parseFieldMethodPrefix()
                    else -> panicMode() // todo right?
                }
            }
            is Token.Identifier -> {
                parseFieldMethodPrefix()
            }
            else -> panicMode() // todo right?
        }
    }

    private fun parseMainMethod(): AST.MainMethod {
        expectKeyword(Token.Keyword.Type.Static)
        expectKeyword(Token.Keyword.Type.Void)

        val ident = expectIdentifier()

        expectOperator(Token.Operator.Type.LParen)
        val parameter = parseParameter()
        expectOperator(Token.Operator.Type.RParen)

        val maybeThrowsToken = peek(0)
        if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
            parseMethodRest()
        }

        val block = parseBlock()
        return AST.MainMethod(
            ident.name,
            Type.Void,
            listOf(parameter),
            block
        )
    }

    private fun parseFieldMethodPrefix(): AST.ClassMember {
        val type = parseType()
        val ident = expectIdentifier()
        val fieldMethodRestToken = peek(0)
        return when (fieldMethodRestToken) {
            is Token.Operator -> {
                when (fieldMethodRestToken.type) {
                    Token.Operator.Type.Semicolon -> parseField(ident, type)
                    Token.Operator.Type.LParen -> parseMethod(ident, type)
                    else -> panicMode() // todo right?
                }
            }
            else -> panicMode() // todo right?
        }
    }

    private fun parseField(ident: Token.Identifier, type: Type): AST.Field {
        expectOperator(Token.Operator.Type.Semicolon)
        return AST.Field(
            ident.name,
            type
        )
    }

    private fun parseMethod(ident: Token.Identifier, type: Type): AST.Method {
        expectOperator(Token.Operator.Type.LParen)
        val maybeRParenToken = peek(0)
        val parameters =
            if (!(maybeRParenToken is Token.Operator && maybeRParenToken.type == Token.Operator.Type.RParen)) {
                parseParameters()
            } else emptyList()
        expectOperator(Token.Operator.Type.RParen)

        val maybeThrowsToken = peek(0)
        val methodRest = if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
            parseMethodRest()
        } else {
            null
        }
        val block = parseBlock()
        return AST.Method(
            ident.name,
            type,
            parameters,
            block,
            methodRest
        )
    }

    internal fun parseBlock(): AST.Block {
        expectOperator(Token.Operator.Type.LeftBrace)

        val maybeRightBrace = peek(0)
        val resultBlock = AST.Block(
            if (!(maybeRightBrace is Token.Operator && maybeRightBrace.type == Token.Operator.Type.RightBrace)) {
                parseBlockStatements()
            } else emptyList()
        )

        expectOperator(Token.Operator.Type.RightBrace)
        return resultBlock
    }

    private fun parseBlockStatements(): List<AST.BlockStatement> {
        // at least one should exist at this point.
        return buildList<AST.BlockStatement> {
            var peeked = peek(0)
            while (!(peeked is Token.Operator && peeked.type == Token.Operator.Type.RightBrace)) {
                add(parseBlockStatement())
                peeked = peek(0)
            }
        }
    }

    private fun parseBlockStatement(): AST.BlockStatement {
        // Statement ==> "{ | ; | if | while | return | null | false | true | INTEGER_LITERAL | ( | IDENT | this | new"
        // Statement: Auf IDENT folgt nie ein weiteres IDENT.
        // LocalVariableDeclarationStatement ==> "int | boolean | void | IDENT" x " IDENT " x " = | ; "
        return when (val firstToken = peek(0)) {
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If,
                    Token.Keyword.Type.While,
                    Token.Keyword.Type.Return,
                    Token.Keyword.Type.Null,
                    Token.Keyword.Type.False,
                    Token.Keyword.Type.True,
                    Token.Keyword.Type.This,
                    Token.Keyword.Type.New -> parseStatement()

                    Token.Keyword.Type.Int,
                    Token.Keyword.Type.Boolean,
                    Token.Keyword.Type.Void -> parseLocalVariableDeclarationStatement()

                    else -> panicMode() // TODO this might not be the right place
                }
            }
            is Token.Literal -> parseStatement()
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace,
                    Token.Operator.Type.Semicolon,
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseStatement()

                    else -> panicMode() // TODO this might not be the right place
                }
            }
            is Token.Identifier -> {
                // Lookahead = 3 needed, here!
                when (val secondToken = peek(1)) {
                    is Token.Identifier -> parseLocalVariableDeclarationStatement()
                    is Token.Operator -> {
                        if (secondToken.type == Token.Operator.Type.LeftBracket) {
                            when (val thirdToken = peek(2)) {
                                is Token.Operator -> {
                                    if (thirdToken.type == Token.Operator.Type.RightBracket) {
                                        parseLocalVariableDeclarationStatement()
                                    } else {
                                        parseStatement()
                                    }
                                }
                                else -> parseStatement()
                            }
                        } else {
                            parseStatement()
                        }
                    }
                    else -> parseStatement()
                }
            }
            else -> panicMode()
        }
    }

    internal fun parseStatement(): AST.Statement {
        return when (val firstToken = peek(0)) {
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace -> parseBlock()
                    Token.Operator.Type.Semicolon -> parseEmptyStatement()
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseExpressionStatement()

                    else -> panicMode() // TODO this might not be the right place
                }
            }
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If -> parseIfStatement()
                    Token.Keyword.Type.While -> parseWhileStatement()
                    Token.Keyword.Type.Return -> parseReturnStatement()
                    Token.Keyword.Type.Null -> parseExpressionStatement()
                    Token.Keyword.Type.False -> parseExpressionStatement()
                    Token.Keyword.Type.True -> parseExpressionStatement()
                    Token.Keyword.Type.This -> parseExpressionStatement()
                    Token.Keyword.Type.New -> parseExpressionStatement()

                    else -> panicMode() // TODO this might not be the right place
                }
            }
            is Token.Literal -> parseExpressionStatement()
            is Token.Identifier -> parseExpressionStatement()
            else -> panicMode() // TODO this might not be the right place
        }
    }

    private fun parseReturnStatement(): AST.ReturnStatement {
        expectKeyword(Token.Keyword.Type.Return)
        val maybeSemicolon = peek(0)
        var returnValue: AST.Expression? = null
        if (!(maybeSemicolon is Token.Operator && maybeSemicolon.type == Token.Operator.Type.Semicolon)) {
            returnValue = parseExpression()
        }
        expectOperator(Token.Operator.Type.Semicolon)
        return AST.ReturnStatement(returnValue)
    }

    private fun parseIfStatement(): AST.IfStatement {
        expectKeyword(Token.Keyword.Type.If)
        expectOperator(Token.Operator.Type.LParen)
        val condition = parseExpression()
        expectOperator(Token.Operator.Type.RParen)
        val trueStatement = parseStatement()

        val maybeElseToken = peek(0)
        var falseStatement: AST.Statement? = null
        if (maybeElseToken is Token.Keyword && maybeElseToken.type == Token.Keyword.Type.Else) {
            expectKeyword(Token.Keyword.Type.Else)
            falseStatement = parseStatement()
        }
        return AST.IfStatement(
            condition,
            trueStatement,
            falseStatement
        )
    }

    private fun parseWhileStatement(): AST.WhileStatement {
        expectKeyword(Token.Keyword.Type.While)
        expectOperator(Token.Operator.Type.LParen)
        val loopCondition = parseExpression()
        expectOperator(Token.Operator.Type.RParen)
        val loopBodyStatement = parseStatement()

        return AST.WhileStatement(loopCondition, loopBodyStatement)
    }

    private fun parseEmptyStatement(): AST.EmptyStatement {
        expectOperator(Token.Operator.Type.Semicolon)
        return AST.EmptyStatement
    }

    private fun parseLocalVariableDeclarationStatement(): AST.LocalVariableDeclarationStatement {
        val type = parseType()
        val varName = expectIdentifier()
        val initializer = when (val nextToken = peek()) {
            is Token.Operator ->
                if (nextToken.type == Token.Operator.Type.Assign) {
                    next()
                    parseExpression()
                } else {
                    null
                }
            else -> null
        }
        expectOperator(Token.Operator.Type.Semicolon)
        return AST.LocalVariableDeclarationStatement(varName.name, type, initializer)
    }

    private fun parseExpressionStatement(): AST.ExpressionStatement {
        val expr = parseExpression()
        expectOperator(Token.Operator.Type.Semicolon)
        return AST.ExpressionStatement(expr)
    }

    /**
     * TODO this can be ignored since we dont handle exceptions semantically?
     */
    private fun parseMethodRest(): Token.Identifier {
        expectKeyword(Token.Keyword.Type.Throws)
        return expectIdentifier()
    }

    private fun parseParameters(): List<AST.Parameter> {

        return buildList<AST.Parameter> {
            add(parseParameter())
            var maybeCommaToken = peek(0)
            while (maybeCommaToken is Token.Operator && maybeCommaToken.type == Token.Operator.Type.Comma) {
                expectOperator(Token.Operator.Type.Comma) // never fails
                add(parseParameter())
                maybeCommaToken = peek(0)
            }
        }
    }

    private fun parseParameter(): AST.Parameter {
        val type = parseType()
        val ident = expectIdentifier()
        return AST.Parameter(
            ident.name,
            type
        )
    }

    private fun parseType(): Type {
        val basicType = parseBasicType()
        val maybeLeftBracket = peek(0)
        if (maybeLeftBracket is Token.Operator && maybeLeftBracket.type == Token.Operator.Type.LeftBracket) {
            return parseTypeArrayRecurse(basicType)
        }
        return basicType
    }

    private fun parseTypeArrayRecurse(basicType: Type): Type.Array {
        expectOperator(Token.Operator.Type.LeftBracket)
        expectOperator(Token.Operator.Type.RightBracket)
        val maybeAnotherLBracket = peek(0)
        return if (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) {
            Type.Array(parseTypeArrayRecurse(basicType))
        } else Type.Array(basicType)
    }

    private fun parseBasicType(): Type {
        return when (val typeToken = next()) {
            is Token.Keyword -> {
                when (typeToken.type) {
                    Token.Keyword.Type.Int -> Type.Integer
                    Token.Keyword.Type.Boolean -> Type.Boolean
                    Token.Keyword.Type.Void -> Type.Void
                    else -> panicMode()
                }
            }
            is Token.Identifier -> {
                Type.ClassType(typeToken.name)
            }
            else -> panicMode()
        }
    }
}
