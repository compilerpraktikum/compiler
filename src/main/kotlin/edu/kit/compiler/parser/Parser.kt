package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.ast.AST
import edu.kit.compiler.ast.Type
import edu.kit.compiler.ast.toASTOperation
import edu.kit.compiler.lex.Lexer
import edu.kit.compiler.lex.SourceFile
import edu.kit.compiler.lex.Symbol
import edu.kit.compiler.wrapper.LenientProgram
import edu.kit.compiler.wrapper.Of
import edu.kit.compiler.wrapper.wrappers.Lenient
import edu.kit.compiler.wrapper.wrappers.markErroneous
import edu.kit.compiler.wrapper.wrappers.wrapErroneous
import edu.kit.compiler.wrapper.wrappers.wrapValid
import java.util.Optional

private val Token.isRelevantForSyntax
    get() = when (this) {
        is Token.Whitespace, is Token.Comment, is Token.ErrorToken -> false
        else -> true
    }

/**
 * Parser that consumes a token sequence generated by [Lexer.tokens] and generates an abstract syntax tree from it.
 *
 * @param tokens [Sequence] of [tokens][Token]
 * @param sourceFile input wrapper that handles error reporting
 */
@ExperimentalStdlibApi
class Parser(sourceFile: SourceFile, tokens: Sequence<Token>) :
    AbstractParser(tokens.filter(Token::isRelevantForSyntax), sourceFile) {

    /**
     * Parse the lexer stream into an AST.
     */
    override fun parse(): Lenient<LenientProgram> {
        val classDeclarations = parseClassDeclarations(anchorSetOf(Token.Eof()).intoUnion())
        val eof = expect<Token.Eof>(anchorSetOf().intoUnion()) { "expected end of file" }

        return if (eof.isPresent)
            AST.Program(classDeclarations).wrapValid()
        else
            AST.Program(classDeclarations).wrapErroneous()
    }

    private fun parsePrimaryExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        return when (val peekedToken = peek()) {
            is Token.Literal -> {
                next()
                AST.LiteralExpression(peekedToken.value).wrapValid() // TODO we should further specify ""type""
            }
            is Token.Operator -> {
                if (peekedToken.type == Token.Operator.Type.LParen) {
                    next()
                    val innerExpr = parseExpression(1, anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    expectOperator(Token.Operator.Type.RParen, anc) { "expected closing parenthesis." }
                    innerExpr
                } else {
                    reportError(
                        peekedToken,
                        "illegal token `${peekedToken.debugRepr}`, expected expression",
                    )
                    recover(anc)
                    Lenient.Error(null)
                }
            }
            is Token.Identifier -> {
                val reference = next() as Token.Identifier

                val maybeLParent = peek(0)
                if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                    next()
                    val arguments = parseArguments(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    val rParen = expectOperator(Token.Operator.Type.RParen, anc) { "expected `)`" }

                    if (rParen.isPresent) {
                        AST.MethodInvocationExpression(null, reference.name, arguments).wrapValid()
                    } else {
                        AST.MethodInvocationExpression(null, reference.name, arguments).wrapErroneous()
                    }
                } else {
                    AST.IdentifierExpression(reference.name).wrapValid()
                }
            }
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Null -> {
                        next()
                        AST.LiteralExpression("null").wrapValid()
                    }
                    Token.Keyword.Type.False -> {
                        next()
                        AST.LiteralExpression(false).wrapValid()
                    }
                    Token.Keyword.Type.True -> {
                        next()
                        AST.LiteralExpression(true).wrapValid()
                    }
                    Token.Keyword.Type.This -> {
                        next()
                        AST.LiteralExpression("this").wrapValid()
                    }
                    Token.Keyword.Type.New -> {
                        next()
                        parseNewObjectArrayExpression(anc)
                    }
                    else -> {
                        reportError(
                            peekedToken,
                            "illegal token `${peekedToken.debugRepr}`. expected expression",
                        )
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            else -> {
                reportError(
                    peekedToken,
                    "illegal token `${peekedToken.debugRepr}`. expected expression",
                )
                recover(anc)
                return Lenient.Error(null)
            }
        }
    }

    /**
     *
     */
    private fun parseNewObjectArrayExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        return when (val firstToken = peek()) {
            is Token.Keyword -> when (firstToken.type) {
                Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                    parseNewArrayExpression(anc)
                else -> {
                    reportError(firstToken, "illegal token `${firstToken.debugRepr}`. expected type")
                    recover(anc)
                    return Lenient.Error(null)
                }
            }
            is Token.Identifier -> {
                // k=2
                when (val secondToken = peek(1)) {
                    is Token.Operator -> {
                        when (secondToken.type) {
                            Token.Operator.Type.LParen -> parseNewObjectExpression(anc)
                            Token.Operator.Type.LeftBracket -> parseNewArrayExpression(anc)
                            else -> {
                                reportError(
                                    secondToken,
                                    "illegal token `${secondToken.debugRepr}`. expected constructor call or array type",
                                )
                                recover(anc)
                                return Lenient.Error(null)
                            }
                        }
                    }
                    else -> {
                        reportError(
                            secondToken,
                            "illegal token `${secondToken.debugRepr}`. expected constructor call or array type",
                        )
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            else -> {
                reportError(firstToken, "illegal token `${firstToken.debugRepr}`. expected type")
                recover(anc)
                return Lenient.Error(null)
            }
        }
    }

    private fun parseNewObjectExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        val ident = next() as Token.Identifier
        next() // skip open parenthesis
        val rParen = expectOperator(Token.Operator.Type.RParen, anc) { "constructor calls must be empty. expected `)`" }

        return if (rParen.isPresent) {
            AST.NewObjectExpression(ident.name).wrapValid()
        } else {
            AST.NewObjectExpression(ident.name).wrapErroneous()
        }
    }

    private fun parseNewArrayExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        val basicType = parseBasicType(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LeftBracket),
                    Token.Operator(Token.Operator.Type.RightBracket)
                ) +
                FirstFollowUtils.firstSetExpression
        )
        next() // skip bracket

        val indexExpression = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)))

        val rBracket = expectOperator(Token.Operator.Type.RightBracket, anc) { "expected `]`" }

        val arrayType = if (rBracket.isPresent) {
            parseNewArrayExpressionTypeArrayRecurse(Type.Array.ArrayType(basicType).wrapValid(), anc)
        } else {
            parseNewArrayExpressionTypeArrayRecurse(Type.Array.ArrayType(basicType).wrapErroneous(), anc)
        }

        return AST.NewArrayExpression(arrayType, indexExpression).wrapValid()
    }

    private fun parseNewArrayExpressionTypeArrayRecurse(
        basicType: Lenient<Type.Array.ArrayType<Lenient<Of>>>,
        anc: AnchorUnion
    ): Lenient<Type.Array.ArrayType<Lenient<Of>>> {
        val maybeAnotherLBracket = peek(0)
        // special case for NewArrayExpression in combination with ArrayAccess
        // (in "PostfixExpression -> PrimaryExpression (PostfixOp)*" Production)
        val maybeAnotherRBracket = peek(1)

        return if (
            (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) &&
            (maybeAnotherRBracket is Token.Operator && maybeAnotherRBracket.type == Token.Operator.Type.RightBracket)
        ) {
            next()
            next()
            Type.Array.ArrayType(parseNewArrayExpressionTypeArrayRecurse(basicType, anc).map { it.wrapArray() })
                .wrapValid()
        } else {
            basicType
        }
    }

    private fun parseArguments(anc: AnchorUnion): List<Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>>> {
        val arguments = mutableListOf<Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>>>()
        var nextToken = peek()

        /*
         * Intervention: because the loop waits for a specific token to arise, it makes zero sense to recover to
         * tokens from anchor sets outside the loop. We will therefore replace the anchor set with one that
         * contains only tokens from the loop condition, to prevent the parser from spinning on miss-placed tokens
         * that are in the anchor set.
         */
        val loopAnchor = anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Eof())
        while (nextToken !in loopAnchor) {
            if (arguments.isNotEmpty()) {
                expectOperator(
                    Token.Operator.Type.Comma,
                    loopAnchor +
                        FirstFollowUtils.firstSetExpression +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RParen))
                ) { "arguments must be comma-separated" }
            }
            arguments += parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
            nextToken = peek()
        }
        return arguments
    }

    private fun parsePostfixExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        val primaryExpression = parsePrimaryExpression(anc + FirstFollowUtils.firstSetPostfixOp)

        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot,
                    Token.Operator.Type.LeftBracket -> parsePostfixOp(
                        primaryExpression,
                        anc + FirstFollowUtils.firstSetPostfixOp
                    )
                    else -> return primaryExpression
                }
            else -> return primaryExpression
        }
    }

    private fun parsePostfixOp(
        target: Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>>,
        anc: AnchorUnion
    ): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot -> {
                        next()

                        val ident = expectIdentifier(
                            anc +
                                anchorSetOf(
                                    Token.Operator(Token.Operator.Type.LParen),
                                    Token.Operator(Token.Operator.Type.RParen),
                                ) +
                                FirstFollowUtils.firstSetArguments +
                                FirstFollowUtils.firstSetPostfixOp
                        ) { "expected member identifier" }

                        val maybeLParent = peek()
                        if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                            // methodInvocation todo recurse
                            next()

                            val arguments = parseArguments(
                                anc +
                                    anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                                    FirstFollowUtils.firstSetPostfixOp
                            )

                            expectOperator(
                                Token.Operator.Type.RParen,
                                anc + FirstFollowUtils.firstSetPostfixOp,
                            ) { "expected `)`" }

                            if (ident.isPresent) {
                                parsePostfixOp(
                                    AST.MethodInvocationExpression(target, ident.get().name, arguments).wrapValid(),
                                    anc
                                )
                            } else {
                                parsePostfixOp(
                                    AST.MethodInvocationExpression(target, Token.Identifier.Placeholder.name, arguments)
                                        .wrapErroneous(),
                                    anc
                                )
                            }
                        } else {
                            // fieldAccess todo recurse
                            if (ident.isPresent) {
                                parsePostfixOp(AST.FieldAccessExpression(target, ident.get().name).wrapValid(), anc)
                            } else {
                                parsePostfixOp(
                                    AST.FieldAccessExpression(target, Token.Identifier.Placeholder.name)
                                        .wrapErroneous(),
                                    anc
                                )
                            }
                        }
                        // k=3 because lazy. Maybe change this if needed later on
                    }
                    Token.Operator.Type.LeftBracket -> {
                        next()

                        val index = parseExpression(
                            anc = anc +
                                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                                FirstFollowUtils.firstSetPostfixOp
                        )

                        val rBracket = expectOperator(
                            Token.Operator.Type.RightBracket,
                            anc + FirstFollowUtils.firstSetPostfixOp
                        ) { "expected `]`" }

                        if (rBracket.isPresent) {
                            parsePostfixOp(AST.ArrayAccessExpression(target, index).wrapValid(), anc)
                        } else {
                            parsePostfixOp(AST.ArrayAccessExpression(target, index).wrapErroneous(), anc)
                        }
                    }
                    else -> target
                }
            else -> target
        }
    }

    private fun parseUnaryExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        // todo not exhausting first(follow) of parsePrimary!)
        // TODO parsePostfixExpression instead of parsePrimaryExpression !
        return when (val peeked = peek()) {
            is Token.Operator ->
                when (peeked.type) {
                    Token.Operator.Type.Not -> {
                        next()

                        AST.UnaryExpression(
                            parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators),
                            AST.UnaryExpression.Operation.NOT
                        ).wrapValid()
                    }
                    Token.Operator.Type.Minus -> {
                        next()

                        AST.UnaryExpression(
                            parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators),
                            AST.UnaryExpression.Operation.MINUS
                        ).wrapValid()
                    }
                    else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
                }
            else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
        }
    }

    internal fun parseExpression(
        minPrecedence: Int = 1,
        anc: AnchorUnion
    ): Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>> {
        // todo: calculate anchorsets using all expression operators
        var result = parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators)
        var currentToken = peek()

        while (
            currentToken is Token.Operator &&
            (currentToken.type.toASTOperation()?.precedence?.let { it >= minPrecedence } == true)
        ) {
            val op = currentToken.type.toASTOperation()!!

            next()

            val rhs = parseExpression(
                when (op.associativity) {
                    AST.BinaryExpression.Operation.Associativity.LEFT -> op.precedence + 1
                    else -> op.precedence
                },
                anc + FirstFollowUtils.allExpressionOperators
            )
            result = AST.BinaryExpression(result, rhs, op).wrapValid()
            currentToken = peek()
        }
        return result
    }

    internal fun parseClassDeclarations(anc: AnchorUnion): List<Lenient<AST.ClassDeclaration<Lenient<Of>, Lenient<Of>, Lenient<Of>, Lenient<Of>>>> {
        return buildList {
            while (peek(0) !is Token.Eof) {
                // manual intervention: we read away one visibility modifier if present. Those are illegal here, but we
                // avoid many follow-up errors if we do that. It isn't totally dumb, considering java allows them
                var illegalVisibilityModifier = false
                if (peek() in FirstFollowUtils.visibilityTokens) {
                    reportError(next(), "classes must not have visibility modifiers")
                    illegalVisibilityModifier = true
                }

                val classKeyword = expectKeyword(
                    Token.Keyword.Type.Class,
                    anc +
                        anchorSetOf(
                            Token.Identifier.Placeholder,
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                ) { "expected class declaration" }

                val ident = expect<Token.Identifier>(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                            Token.Eof()
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                ) { "expected class name" }

                val lBrace = expectOperator(
                    Token.Operator.Type.LeftBrace,
                    anc +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                        FirstFollowUtils.firstSetClassMembers
                ) {
                    "missing opening brace"
                }

                val classMembers = parseClassMembers(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)))

                val rBrace = expectOperator(Token.Operator.Type.RightBrace, anc) {
                    "missing closing brace"
                }

                if (classKeyword.isPresent && ident.isPresent && lBrace.isPresent && rBrace.isPresent && !illegalVisibilityModifier) {
                    add(AST.ClassDeclaration(ident.get().name, classMembers).wrapValid())
                } else {
                    add(
                        AST.ClassDeclaration(ident.orElse(Token.Identifier.Placeholder).name, classMembers)
                            .wrapErroneous()
                    )
                }
            }
        }
    }

    private fun parseClassMembers(anc: AnchorUnion): List<Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>, Lenient<Of>>>> {
        return buildList {
            var peeked = peek(0)

            while (true) {
                // read class members while we find visibility tokens. Most of them won't be accepted, but it will
                // improve error messages
                while (peeked in FirstFollowUtils.visibilityTokens) {
                    add(parseClassMember(anc + FirstFollowUtils.firstSetClassMember))
                    peeked = peek(0)
                }

                /*
                 * Manual intervention: Strictly following anchor sets and SLL parsing, we would expect the end of the
                 * class file here, because we did not encounter another `public`. But if we do not see an `}`, we assume
                 * that all following tokens are miss-placed and recover until the next `class` definition starts. This
                 * is stupid however, because this means that one missing `public` will result in all following members
                 * being skipped.
                 * So instead we check if the peeked token is a valid start of a class member after a `public`, and
                 * if so, we will parse it anyway (resulting in an error because `public` is missing, but good recovery
                 * after that). Then, we will try and parse more members starting at `public` again. However, if the
                 * peeked token is not valid even after a `public` token, we will recover towards the next `public` token
                 * (or the end of class as usual).
                 */

                if (peeked !in anc.provide() /* there are only more members if we aren't in follow(classmembers) */) {
                    val semiLegalAnchorSet =
                        FirstFollowUtils.firstSetFieldMethodPrefix + FirstFollowUtils.firstSetMainMethodPrefix
                    if (peeked in semiLegalAnchorSet.provide()) {
                        // this will be illegal, but we get better error reporting from it
                        add(parseClassMember(anc + FirstFollowUtils.visibilityTokens))
                    } else {
                        reportError(peeked, "expected class member definition")
                        recover(anc + FirstFollowUtils.visibilityTokens)
                    }
                    peeked = peek(0)
                } else {
                    break
                }
            }
        }
    }

    private fun parseClassMember(anc: AnchorUnion): Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        val publicKeyword = expectKeyword(
            Token.Keyword.Type.Public,
            anc + anchorSetOf(
                Token.Keyword(Token.Keyword.Type.Static),
                Token.Keyword(Token.Keyword.Type.Int),
                Token.Keyword(Token.Keyword.Type.Boolean),
                Token.Keyword(Token.Keyword.Type.Void),
                Token.Identifier.Placeholder
            )
        ) { "class members must be public" }

        val childNode = when (val token = peek(0)) {
            is Token.Keyword -> {
                when (token.type) {
                    Token.Keyword.Type.Static -> parseMainMethod(anc)
                    Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                        parseFieldMethodPrefix(anc)
                    else -> {
                        reportError(token, "expected `static` or (return) type identifier")
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            is Token.Identifier -> {
                parseFieldMethodPrefix(anc)
            }
            else -> {
                reportError(token, "expected field or method declaration")
                recover(anc)
                return Lenient.Error(null)
            }
        }

        return if (publicKeyword.isPresent) {
            childNode
        } else {
            childNode.markErroneous()
        }
    }

    private fun parseMainMethod(anc: AnchorUnion): Lenient<AST.MainMethod<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        val staticKeyword = expectKeyword(
            Token.Keyword.Type.Static,
            anc +
                anchorSetOf(
                    Token.Keyword(Token.Keyword.Type.Void),
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "main method must be `static`" }

        val voidKeyword = expectKeyword(
            Token.Keyword.Type.Void,
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "main method must return `void`" }

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "expected function name `main`" }

        val leftParen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "missing opening parenthesis" }

        // manually check if a parameter can be parsed before trying, so we can report a more sensible error message
        // than `expected type`
        val peeked = peek()
        val parameter = if (peeked in FirstFollowUtils.firstSetParameter) {
            parseParameter(
                anc +
                    anchorSetOf(
                        Token.Operator(Token.Operator.Type.RParen),
                        Token.Keyword(Token.Keyword.Type.Throws),
                    ) +
                    FirstFollowUtils.firstSetBlock
            )
        } else {
            reportError(peeked, "expected one parameter of type `String[]`")
            recover(
                anc +
                    anchorSetOf(
                        Token.Operator(Token.Operator.Type.RParen),
                        Token.Keyword(Token.Keyword.Type.Throws),
                    ) +
                    FirstFollowUtils.firstSetBlock
            )
            Lenient.Error(null)
        }

        val rightParen = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        ) {
            if (peek() in FirstFollowUtils.firstSetParameter) {
                "main method may only have one parameter of type `String[]`"
            } else {
                "expected closing parenthesis"
            }
        }

        val maybeThrowsToken = peek(0)
        val throwsException =
            if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
                parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
            } else {
                null
            }

        val block = parseBlock(anc)

        return if (staticKeyword.isPresent && voidKeyword.isPresent && ident.isPresent && leftParen.isPresent &&
            rightParen.isPresent && throwsException?.isPresent != false
        ) {
            AST.MainMethod(
                ident.get().name,
                Type.Void.wrapValid(),
                listOf(parameter),
                block,
                throwsException?.get()
            ).wrapValid()
        } else {
            AST.MainMethod(
                ident.orElse(Token.Identifier.Placeholder).name,
                Type.Void.wrapValid(),
                listOf(parameter),
                block,
                throwsException?.orElse(null)
            ).wrapErroneous()
        }
    }

    private fun parseFieldMethodPrefix(anc: AnchorUnion): Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        val type = parseType(
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        )

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        ) { "expected identifier" }

        return when (val fieldMethodRestToken = peek(0)) {
            is Token.Operator -> {
                when (fieldMethodRestToken.type) {
                    Token.Operator.Type.Semicolon -> parseField(ident, type, anc)
                    Token.Operator.Type.LParen -> parseMethod(ident, type, anc)
                    else -> {
                        reportError(
                            fieldMethodRestToken,
                            "illegal class member declaration. expected either a method declaration or `;`",
                        )
                        recover(anc)
                        // todo we could try to recover this towards a method declaration and parse it, if we succeed
                        Lenient.Error(null)
                    }
                }
            }
            else -> {
                reportError(
                    fieldMethodRestToken,
                    "illegal class member declaration. expected either `;` or `(`.",
                )
                recover(anc)
                // todo we could try to recover this towards a method declaration and parse it, if we succeed
                Lenient.Error(null)
            }
        }
    }

    private fun parseField(
        ident: Optional<Token.Identifier>,
        type: Lenient<Type<Lenient<Of>>>,
        anc: AnchorUnion
    ): Lenient<AST.Field<Lenient<Of>>> {
        next()

        return if (ident.isPresent) {
            AST.Field(
                ident.get().name,
                type
            ).wrapValid()
        } else {
            AST.Field(
                ident.orElse(Token.Identifier.Placeholder).name,
                type
            ).wrapErroneous()
        }
    }

    private fun parseMethod(
        ident: Optional<Token.Identifier>,
        type: Lenient<Type<Lenient<Of>>>,
        anc: AnchorUnion
    ): Lenient<AST.Method<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        next()

        val maybeRParenToken = peek(0)
        val parameters =
            if (!(maybeRParenToken is Token.Operator && maybeRParenToken.type == Token.Operator.Type.RParen)) {
                parseParameters(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.RParen),
                            Token.Keyword(Token.Keyword.Type.Throws)
                        ) +
                        FirstFollowUtils.firstSetBlock
                )
            } else emptyList()

        val closingParenthesis = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        ) { "expected `)`" }

        val maybeThrowsToken = peek(0)
        val throwsException =
            if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
                parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
            } else {
                null
            }

        val block = parseBlock(anc)

        if (ident.isPresent && closingParenthesis.isPresent && throwsException?.isPresent != false) {
            return AST.Method(
                ident.get().name,
                type,
                parameters,
                block,
                throwsException?.get()
            ).wrapValid()
        } else {
            return AST.Method(
                ident.orElse(Token.Identifier.Placeholder).name,
                type,
                parameters,
                block,
                throwsException?.orElse(null)
            ).wrapErroneous()
        }
    }

    internal fun parseBlock(anc: AnchorUnion): Lenient<AST.Block<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        val openingBrace = expectOperator(
            Token.Operator.Type.LeftBrace,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                FirstFollowUtils.firstSetBlockStatement
        ) { "expected opening brace" }

        val maybeRightBrace = peek(0)

        val resultBlock = AST.Block(
            if (!(maybeRightBrace is Token.Operator && maybeRightBrace.type == Token.Operator.Type.RightBrace)) {
                parseBlockStatements(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)))
            } else {
                emptyList()
            }
        )

        val closingBrace = expectOperator(Token.Operator.Type.RightBrace, anc) { "expected closing brace" }

        return if (openingBrace.isPresent && closingBrace.isPresent) {
            resultBlock.wrapValid()
        } else {
            resultBlock.wrapErroneous()
        }
    }

    private fun parseBlockStatements(anc: AnchorUnion): List<Lenient<AST.BlockStatement<Lenient<Of>, Lenient<Of>, Lenient<Of>>>> {
        // at least one should exist at this point.
        return buildList {
            var peeked = peek(0)

            /*
             * Intervention: because the loop waits for a specific token to arise, it makes zero sense to recover to
             * tokens from anchor sets outside the loop. We will therefore replace the anchor set with one that
             * contains only tokens from the loop condition, to prevent the parser from spinning on miss-placed tokens
             * that are in the anchor set.
             */
            val loopAnchor = anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace), Token.Eof())
            while (peeked !in loopAnchor) {
                add(parseBlockStatement(loopAnchor + FirstFollowUtils.firstSetBlockStatement))
                peeked = peek(0)
            }
        }
    }

    private fun parseBlockStatement(anc: AnchorUnion): Lenient<AST.BlockStatement<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        // Statement ==> "{ | ; | if | while | return | null | false | true | INTEGER_LITERAL | ( | IDENT | this | new"
        // Statement: Auf IDENT folgt nie ein weiteres IDENT.
        // LocalVariableDeclarationStatement ==> "int | boolean | void | IDENT" x " IDENT " x " = | ; "
        return when (val firstToken = peek(0)) {
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If,
                    Token.Keyword.Type.While,
                    Token.Keyword.Type.Return,
                    Token.Keyword.Type.Null,
                    Token.Keyword.Type.False,
                    Token.Keyword.Type.True,
                    Token.Keyword.Type.This,
                    Token.Keyword.Type.New -> parseStatement(anc).map { AST.StmtWrapper(it) }

                    Token.Keyword.Type.Int,
                    Token.Keyword.Type.Boolean,
                    Token.Keyword.Type.Void -> parseLocalVariableDeclarationStatement(anc)

                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            is Token.Literal -> parseStatement(anc).map { AST.StmtWrapper(it) }
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace,
                    Token.Operator.Type.Semicolon,
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseStatement(anc).map { AST.StmtWrapper(it) }

                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            is Token.Identifier -> {
                // Lookahead = 3 needed, here!
                when (val secondToken = peek(1)) {
                    is Token.Identifier -> parseLocalVariableDeclarationStatement(anc)
                    is Token.Operator -> {
                        if (secondToken.type == Token.Operator.Type.LeftBracket) {
                            when (val thirdToken = peek(2)) {
                                is Token.Operator -> {
                                    if (thirdToken.type == Token.Operator.Type.RightBracket) {
                                        parseLocalVariableDeclarationStatement(anc)
                                    } else {
                                        parseStatement(anc).map { AST.StmtWrapper(it) }
                                    }
                                }
                                else -> parseStatement(anc).map { AST.StmtWrapper(it) }
                            }
                        } else {
                            parseStatement(anc).map { AST.StmtWrapper(it) }
                        }
                    }
                    else -> parseStatement(anc).map { AST.StmtWrapper(it) }
                }
            }
            else -> {
                reportError(
                    firstToken,
                    "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                )
                recover(anc)
                return Lenient.Error(null)
            }
        }
    }

    internal fun parseStatement(anc: AnchorUnion): Lenient<AST.Statement<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        return when (val firstToken = peek(0)) {
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace -> parseBlock(anc)
                    Token.Operator.Type.Semicolon -> parseEmptyStatement(anc)
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseExpressionStatement(anc)
                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If -> parseIfStatement(anc)
                    Token.Keyword.Type.While -> parseWhileStatement(anc)
                    Token.Keyword.Type.Return -> parseReturnStatement(anc)
                    Token.Keyword.Type.Null -> parseExpressionStatement(anc)
                    Token.Keyword.Type.False -> parseExpressionStatement(anc)
                    Token.Keyword.Type.True -> parseExpressionStatement(anc)
                    Token.Keyword.Type.This -> parseExpressionStatement(anc)
                    Token.Keyword.Type.New -> parseExpressionStatement(anc)
                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            is Token.Literal -> parseExpressionStatement(anc)
            is Token.Identifier -> parseExpressionStatement(anc)
            else -> {
                reportError(
                    firstToken,
                    "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                )
                recover(anc)
                return Lenient.Error(null)
            }
        }
    }

    private fun parseReturnStatement(anc: AnchorUnion): Lenient<AST.ReturnStatement<Lenient<Of>, Lenient<Of>>> {
        next()

        val maybeSemicolon = peek(0)
        var returnValue: Lenient<AST.Expression<Lenient<Of>, Lenient<Of>>>? = null
        if (!(maybeSemicolon is Token.Operator && maybeSemicolon.type == Token.Operator.Type.Semicolon)) {
            returnValue = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        }

        next()

        return AST.ReturnStatement(returnValue).wrapValid()
    }

    private fun parseIfStatement(anc: AnchorUnion): Lenient<AST.IfStatement<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        next()

        val lparen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Else),
                ) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        ) { "missing `(`: if-conditions must be wrapped in parenthesis" }

        val condition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        )

        val rparen = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        ) { "missing `)`: if-conditions must be wrapped in parenthesis" }

        val trueStatement = parseStatement(anc + anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)))

        val maybeElseToken = peek(0)
        var falseStatement: Lenient<AST.Statement<Lenient<Of>, Lenient<Of>, Lenient<Of>>>? = null
        if (maybeElseToken is Token.Keyword && maybeElseToken.type == Token.Keyword.Type.Else) {
            next()
            falseStatement = parseStatement(anc)
        }

        return if (lparen.isPresent && rparen.isPresent) {
            AST.IfStatement(
                condition,
                trueStatement,
                falseStatement
            ).wrapValid()
        } else {
            AST.IfStatement(
                condition,
                trueStatement,
                falseStatement
            ).wrapErroneous()
        }
    }

    private fun parseWhileStatement(anc: AnchorUnion): Lenient<AST.WhileStatement<Lenient<Of>, Lenient<Of>, Lenient<Of>>> {
        next()

        val lparen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        ) { "missing `(`: loop-conditions must be wrapped in parenthesis" }

        val loopCondition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetStatement
        )

        val rparen = expectOperator(
            Token.Operator.Type.RParen,
            anc + FirstFollowUtils.firstSetStatement
        ) { "missing `)`: loop-conditions must be wrapped in parenthesis" }

        val loopBodyStatement = parseStatement(anc)

        return if (lparen.isPresent && rparen.isPresent) {
            AST.WhileStatement(loopCondition, loopBodyStatement).wrapValid()
        } else {
            AST.WhileStatement(loopCondition, loopBodyStatement).wrapErroneous()
        }
    }

    private fun parseEmptyStatement(anc: AnchorUnion): Lenient<AST.Statement<Nothing, Nothing, Nothing>> {
        next()
        return AST.emptyStatement.wrapValid()
    }

    private fun parseLocalVariableDeclarationStatement(anc: AnchorUnion): Lenient<AST.LocalVariableDeclarationStatement<Lenient<Of>, Lenient<Of>>> {
        val type = parseType(
            anc + anchorSetOf(
                Token.Identifier.Placeholder,
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        )

        val varName = expectIdentifier(
            anc + anchorSetOf(
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        ) { "expected identifier" }

        val initializer = when (val nextToken = peek()) {
            is Token.Operator ->
                if (nextToken.type == Token.Operator.Type.Assign) {
                    next()
                    parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
                } else {
                    null
                }
            else -> null
        }

        val semicolon = expectOperator(Token.Operator.Type.Semicolon, anc) { "expected `;`" }

        return if (varName.isPresent && semicolon.isPresent) {
            AST.LocalVariableDeclarationStatement(varName.get().name, type, initializer).wrapValid()
        } else {
            AST.LocalVariableDeclarationStatement(
                varName.orElse(Token.Identifier.Placeholder).name,
                type,
                initializer
            ).wrapErroneous()
        }
    }

    private fun parseExpressionStatement(anc: AnchorUnion): Lenient<AST.ExpressionStatement<Lenient<Of>, Lenient<Of>>> {
        val expr = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        val semicolon = expectOperator(Token.Operator.Type.Semicolon, anc) { "expected `;`" }

        return if (semicolon.isPresent) {
            AST.ExpressionStatement(expr).wrapValid()
        } else {
            AST.ExpressionStatement(expr).wrapErroneous()
        }
    }

    private fun parseMethodRest(anc: AnchorUnion): Optional<Symbol> {
        next()

        return expectIdentifier(anc) { "missing identifier. `throws` requires an exception type" }.map { it.name }
    }

    private fun parseParameters(anc: AnchorUnion): List<Lenient<AST.Parameter<Lenient<Of>>>> {
        return buildList {
            add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))

            var maybeCommaToken = peek(0)
            while (maybeCommaToken is Token.Operator && maybeCommaToken.type == Token.Operator.Type.Comma) {
                next()
                add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))
                maybeCommaToken = peek(0)
            }
        }
    }

    private fun parseParameter(anc: AnchorUnion): Lenient<AST.Parameter<Lenient<Of>>> {
        val type = parseType(anc + anchorSetOf(Token.Identifier.Placeholder))
        val ident = expectIdentifier(anc) { "expected parameter name identifier" }

        return if (ident.isPresent) {
            AST.Parameter(ident.get().name, type).wrapValid()
        } else {
            AST.Parameter(Token.Identifier.Placeholder.name, type).wrapErroneous()
        }
    }

    private fun parseType(anc: AnchorUnion): Lenient<Type<Lenient<Of>>> {
        val basicType = parseBasicType(anc + FirstFollowUtils.firstSetTypeArrayRecurse)

        val maybeLeftBracket = peek(0)
        if (maybeLeftBracket is Token.Operator && maybeLeftBracket.type == Token.Operator.Type.LeftBracket) {
            return parseTypeArrayRecurse(basicType, anc).map { it.wrapArray() }
        }
        return basicType
    }

    private fun parseTypeArrayRecurse(
        basicType: Lenient<Type<Lenient<Of>>>,
        anc: AnchorUnion
    ): Lenient<Type.Array.ArrayType<Lenient<Of>>> {
        next()

        // todo what if there is `int a = new int[2][2];`? This is a new-array-instantiation and immediate array access, is this even covered by the parser?
        val rightBracket = expectOperator(
            Token.Operator.Type.RightBracket,
            anc + FirstFollowUtils.firstSetTypeArrayRecurse
        ) { "illegal array type expression. expected `]`" }

        // TODO: in case of error, return an error-node
        val maybeAnotherLBracket = peek(0)
        return if (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) {
            if (rightBracket.isPresent) {
                Type.Array.ArrayType(parseTypeArrayRecurse(basicType, anc).map { it.wrapArray() }).wrapValid()
            } else {
                Type.Array.ArrayType(parseTypeArrayRecurse(basicType, anc).map { it.wrapArray() }).wrapErroneous()
            }
        } else {
            if (rightBracket.isPresent)
                Type.Array.ArrayType(basicType).wrapValid()
            else
                Type.Array.ArrayType(basicType).wrapErroneous()
        }
    }

    private fun parseBasicType(anc: AnchorUnion): Lenient<Type<Lenient<Of>>> {
        return when (val peekedToken = peek()) {
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Int -> {
                        next()
                        Type.Integer.wrapValid()
                    }
                    Token.Keyword.Type.Boolean -> {
                        next()
                        Type.Boolean.wrapValid()
                    }
                    Token.Keyword.Type.Void -> {
                        next()
                        Type.Void.wrapValid()
                    }
                    else -> {
                        reportError(peekedToken, "illegal token `${peekedToken.debugRepr}`. expected type")
                        recover(anc)
                        return Lenient.Error(null)
                    }
                }
            }
            is Token.Identifier -> {
                val t = expectIdentifier(anc) { "expected type identifier" }
                return if (t.isPresent) {
                    Type.Class(t.get().name).wrapValid()
                } else {
                    Type.Class(Token.Identifier.Placeholder.name).wrapErroneous()
                }
            }
            else -> {
                reportError(peekedToken, "illegal token `${peekedToken.debugRepr}`. expected type")
                recover(anc)
                return Lenient.Error(null)
            }
        }
    }
}
