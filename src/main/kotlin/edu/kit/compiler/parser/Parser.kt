package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.ast.AST
import edu.kit.compiler.ast.toASTOperation
import edu.kit.compiler.lex.AbstractLexer
import kotlinx.coroutines.flow.Flow

/**
 * Asynchronous parser that consumes a lexer flow generated by [AbstractLexer.tokens] and generates an [ASTNode] from
 * it.
 *
 * @param lexer [AbstractLexer] implementation providing a flow of [edu.kit.compiler.Token]
 */
class Parser(tokens: Flow<Token>) : AbstractParser<AST.Program>(tokens) {
    /**
     * Parse the lexer stream into an AST. Suspends when the lexer isn't fast enough.
     */
    override suspend fun parseAST(): AST.Program {
        val classDeclarations = parseClassDeclarations()
        TODO("return constructProgramNode(classDeclarations)")
    }

    private suspend fun parsePrimaryExpression() : AST.Expression =
        when(val next = peek()) {
            is Token.Literal -> {
                next()
                AST.LiteralExpression(next.value.toInt())
            }
            is Token.Operator ->
                if (next.type == Token.Operator.Type.LParen) {
                    next()
                    val innerExpr = parseExpr(1)
                    val tokenAfterParens = this.next()
                    if (tokenAfterParens is Token.Operator && tokenAfterParens.type == Token.Operator.Type.RParen) {
                        innerExpr
                    } else {
                        // TODO proper error handling
                        throw IllegalArgumentException("expected closing RPAREN")
                    }
                } else {
                    throw IllegalArgumentException("unexpected operator: $next")
                }
            else -> throw IllegalArgumentException("unexpected token $next")
        }

    suspend fun parseExpr(minPrecedence: Int = 1) : AST.Expression {
        var result = parsePrimaryExpression()
        var currentToken = peek()

        while (
            currentToken is Token.Operator &&
            (currentToken.type.toASTOperation()?.precedence?.let { it >= minPrecedence } == true)
        ) {
            val op = currentToken.type.toASTOperation()!!

            next()

            val rhs = parseExpr(
                when (op.associativity) {
                    AST.BinaryExpression.Operation.Associativity.LEFT -> op.precedence + 1
                    else -> op.precedence
                }
            )
            result = AST.BinaryExpression(result, rhs, op)
            currentToken = peek()
        }
        return result
    }

    suspend fun parseClassDeclarations(): List<AST.ClassDeclaration> {
        while (peek(0) != Token.Eof) {
            expectKeyword(Token.Keyword.Type.Class)
            val ident = expect<Token.Identifier>()
            expectOperator(Token.Operator.Type.LeftBrace)
            val classMembers = parseClassMembers()
            expectOperator(Token.Operator.Type.RightBrace)

            // val classNode constructClassNode(ident, classMembers)
        }

        expect<Token.Eof>()

        return TODO()
    }

    suspend fun parseClassMembers(): List<AST.ClassMember> {
        TODO()
    }

    private suspend inline fun expectOperator(type: Token.Operator.Type): Token.Operator {
        val token = next()
        if (token !is Token.Operator)
            enterPanicMode()

        if (token.type == type)
            return token
        else
            enterPanicMode()
    }

    private suspend inline fun expectKeyword(type: Token.Keyword.Type): Token.Keyword {
        val token = next()
        if (token !is Token.Keyword)
            enterPanicMode()

        if (token.type == type)
            return token
        else
            enterPanicMode()
    }
}
