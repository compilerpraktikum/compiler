package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.ast.AST
import edu.kit.compiler.ast.toASTOperation
import edu.kit.compiler.lex.Lexer
import edu.kit.compiler.lex.SourceFile
import edu.kit.compiler.lex.Symbol
import edu.kit.compiler.wrapper.wrappers.Parsed
import edu.kit.compiler.wrapper.wrappers.markErroneous
import edu.kit.compiler.wrapper.wrappers.wrapErroneous
import edu.kit.compiler.wrapper.wrappers.wrapValid

private val Token.isRelevantForSyntax
    get() = when (this) {
        is Token.Whitespace, is Token.Comment, is Token.ErrorToken -> false
        else -> true
    }

/**
 * Parser that consumes a token sequence generated by [Lexer.tokens] and generates an abstract syntax tree from it.
 *
 * @param tokens [Sequence] of [tokens][Token]
 * @param sourceFile input wrapper that handles error reporting
 */
@ExperimentalStdlibApi
class Parser(sourceFile: SourceFile, tokens: Sequence<Token>) :
    AbstractParser(tokens.filter(Token::isRelevantForSyntax), sourceFile) {

    /**
     * Parse the lexer stream into an AST.
     */
    override fun parse(): Parsed<AST.Program> {
        val programStart = peek().range
        val classDeclarations = parseClassDeclarations(anchorSetOf(Token.Eof()).intoUnion())
        val eof = expect<Token.Eof>(anchorSetOf().intoUnion()) { "expected end of file" }

        return eof.replaceNode {
            AST.Program(classDeclarations)
        }.mapPosition { programStart.extend(eof.range) }
    }

    private fun parsePrimaryExpression(anc: AnchorUnion): Parsed<AST.Expression> {
        return when (val peekedToken = peek()) {
            is Token.Literal -> {
                next()
                AST.LiteralExpression.Integer(peekedToken.value).wrapValid(peekedToken.range)
            }
            is Token.Operator -> {
                if (peekedToken.type == Token.Operator.Type.LParen) {
                    next()
                    val innerExpr = parseExpression(1, anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    expectOperator(Token.Operator.Type.RParen, anc) { "expected closing parenthesis." }
                    innerExpr
                } else {
                    reportError(
                        peekedToken,
                        "illegal token `${peekedToken.debugRepr}`, expected expression",
                    )
                    recover(anc)
                    Parsed.Error(peekedToken.range, null)
                }
            }
            is Token.Identifier -> {
                val reference = next() as Token.Identifier

                val maybeLParent = peek(0)
                if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                    next()
                    val arguments = parseArguments(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    val rParen = expectOperator(Token.Operator.Type.RParen, anc) { "expected `)`" }

                    val invocationExpression =
                        AST.MethodInvocationExpression(null, reference.name.wrapValid(reference.range), arguments)
                    rParen.map {
                        invocationExpression
                    }.mapPosition {
                        peekedToken.range.extend(rParen.range)
                    }
                } else {
                    AST.IdentifierExpression(reference.name.wrapValid(reference.range)).wrapValid(reference.range)
                }
            }
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Null -> {
                        next()
                        AST.LiteralExpression.Null().wrapValid(peekedToken.range)
                    }
                    Token.Keyword.Type.False -> {
                        next()
                        AST.LiteralExpression.Boolean(false).wrapValid(peekedToken.range)
                    }
                    Token.Keyword.Type.True -> {
                        next()
                        AST.LiteralExpression.Boolean(true).wrapValid(peekedToken.range)
                    }
                    Token.Keyword.Type.This -> {
                        next()
                        AST.LiteralExpression.This().wrapValid(peekedToken.range)
                    }
                    Token.Keyword.Type.New -> {
                        next()
                        parseNewObjectArrayExpression(anc)
                    }
                    else -> {
                        reportError(
                            peekedToken,
                            "illegal token `${peekedToken.debugRepr}`. expected expression",
                        )
                        recover(anc)
                        return Parsed.Error(peekedToken.range, null)
                    }
                }
            }
            else -> {
                reportError(
                    peekedToken,
                    "illegal token `${peekedToken.debugRepr}`. expected expression",
                )
                recover(anc)
                return Parsed.Error(peekedToken.range, null)
            }
        }
    }

    /**
     *
     */
    private fun parseNewObjectArrayExpression(anc: AnchorUnion): Parsed<AST.Expression> {
        return when (val firstToken = peek()) {
            is Token.Keyword -> when (firstToken.type) {
                Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                    parseNewArrayExpression(anc)
                else -> {
                    reportError(firstToken, "illegal token `${firstToken.debugRepr}`. expected type")
                    recover(anc)
                    return Parsed.Error(firstToken.range, null)
                }
            }
            is Token.Identifier -> {
                // k=2
                val secondToken = peek(1)
                val twoTokenRange = firstToken.range.extend(secondToken.range)
                when (secondToken) {
                    is Token.Operator -> {
                        when (secondToken.type) {
                            Token.Operator.Type.LParen -> parseNewObjectExpression(anc)
                            Token.Operator.Type.LeftBracket -> parseNewArrayExpression(anc)
                            else -> {
                                reportError(
                                    secondToken,
                                    "illegal token `${secondToken.debugRepr}`. expected constructor call or array type",
                                )
                                recover(anc)
                                return Parsed.Error(twoTokenRange, null)
                            }
                        }
                    }
                    else -> {
                        reportError(
                            secondToken,
                            "illegal token `${secondToken.debugRepr}`. expected constructor call or array type",
                        )
                        recover(anc)
                        return Parsed.Error(twoTokenRange, null)
                    }
                }
            }
            else -> {
                reportError(firstToken, "illegal token `${firstToken.debugRepr}`. expected type")
                recover(anc)
                return Parsed.Error(firstToken.range, null)
            }
        }
    }

    private fun parseNewObjectExpression(anc: AnchorUnion): Parsed<AST.Expression> {
        val ident = next() as Token.Identifier
        next() // skip open parenthesis
        val rParen = expectOperator(Token.Operator.Type.RParen, anc) { "constructor calls must be empty. expected `)`" }

        return rParen.replaceNode { AST.NewObjectExpression(ident.name.wrapValid(ident.range)) }
            .mapPosition { ident.range.extend(rParen.range) }
    }

    private fun parseNewArrayExpression(anc: AnchorUnion): Parsed<AST.Expression> {
        val basicType = parseBasicType(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LeftBracket),
                    Token.Operator(Token.Operator.Type.RightBracket)
                ) +
                FirstFollowUtils.firstSetExpression
        )

        /* We cannot assume that a bracket follows, because in case of primitive arrays no lookahead has happened yet */
        expectOperator(
            Token.Operator.Type.LeftBracket,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                FirstFollowUtils.firstSetExpression
        ) { "expected `[` denoting an array type" }

        val indexExpression = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)))

        val rBracket = expectOperator(Token.Operator.Type.RightBracket, anc) { "expected `]`" }

        val arrayType =
            rBracket.map { AST.Type.Array(basicType) }
                .mapPosition { basicType.range.extend(rBracket.range) }

        val recurseExpression = parseNewArrayExpressionTypeArrayRecurse(arrayType, anc)

        return AST.NewArrayExpression(recurseExpression, indexExpression)
            .wrapValid(basicType.range.extend(recurseExpression.range))
    }

    private fun parseNewArrayExpressionTypeArrayRecurse(
        basicType: Parsed<AST.Type.Array>,
        anc: AnchorUnion
    ): Parsed<AST.Type.Array> {
        val maybeAnotherLBracket = peek(0)

        return if (maybeAnotherLBracket !is Token.Eof) {
            // special case for NewArrayExpression in combination with ArrayAccess
            // (in "PostfixExpression -> PrimaryExpression (PostfixOp)*" Production)
            val maybeAnotherRBracket = peek(1)

            if (
                (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) &&
                (maybeAnotherRBracket is Token.Operator && maybeAnotherRBracket.type == Token.Operator.Type.RightBracket)
            ) {
                next()
                next()
                AST.Type.Array(parseNewArrayExpressionTypeArrayRecurse(basicType, anc))
                    .wrapValid(basicType.range.extend(maybeAnotherRBracket.range))
            } else {
                basicType
            }
        } else {
            basicType
        }
    }

    private fun parseArguments(anc: AnchorUnion): List<Parsed<AST.Expression>> {
        val arguments = mutableListOf<Parsed<AST.Expression>>()
        var nextToken = peek()

        /*
         * Intervention: because the loop waits for a specific token to arise, it makes zero sense to recover to
         * tokens from anchor sets outside the loop. We will therefore replace the anchor set with one that
         * contains only tokens from the loop condition, to prevent the parser from spinning on miss-placed tokens
         * that are in the anchor set.
         */
        val loopAnchor = anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Eof())
        while (nextToken !in loopAnchor) {
            if (arguments.isNotEmpty()) {
                expectOperator(
                    Token.Operator.Type.Comma,
                    loopAnchor +
                        FirstFollowUtils.firstSetExpression +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RParen))
                ) { "arguments must be comma-separated" }
            }
            arguments += parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
            nextToken = peek()
        }
        return arguments
    }

    private fun parsePostfixExpression(anc: AnchorUnion): Parsed<AST.Expression> {
        val primaryExpression = parsePrimaryExpression(anc + FirstFollowUtils.firstSetPostfixOp)

        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot,
                    Token.Operator.Type.LeftBracket -> parsePostfixOp(
                        primaryExpression,
                        anc + FirstFollowUtils.firstSetPostfixOp
                    )
                    else -> return primaryExpression
                }
            else -> return primaryExpression
        }
    }

    private fun parsePostfixOp(
        target: Parsed<AST.Expression>,
        anc: AnchorUnion
    ): Parsed<AST.Expression> {
        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot -> {
                        next()

                        val ident = expectIdentifier(
                            anc +
                                anchorSetOf(
                                    Token.Operator(Token.Operator.Type.LParen),
                                    Token.Operator(Token.Operator.Type.RParen),
                                ) +
                                FirstFollowUtils.firstSetArguments +
                                FirstFollowUtils.firstSetPostfixOp
                        ) { "expected member identifier" }
                        val parsedIdent =
                            ident.cases(onValid = { it.name }, onError = { Token.Identifier.Placeholder.name })

                        val maybeLParent = peek()

                        if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                            next()

                            val arguments = parseArguments(
                                anc +
                                    anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                                    FirstFollowUtils.firstSetPostfixOp
                            )

                            val rightParen = expectOperator(
                                Token.Operator.Type.RParen,
                                anc + FirstFollowUtils.firstSetPostfixOp,
                            ) { "expected `)`" }

                            val range = if (rightParen.isValid) {
                                ident.range.extend(rightParen.range)
                            } else {
                                ident.range.extend(arguments.last().range)
                            }

                            if (rightParen.isValid) {
                                parsePostfixOp(
                                    AST.MethodInvocationExpression(target, parsedIdent, arguments).wrapValid(range),
                                    anc
                                )
                            } else {
                                parsePostfixOp(
                                    AST.MethodInvocationExpression(target, parsedIdent, arguments).wrapErroneous(range),
                                    anc
                                )
                            }
                        } else {
                            parsePostfixOp(
                                AST.FieldAccessExpression(target, parsedIdent)
                                    .wrapValid(target.range.extend(parsedIdent.range)),
                                anc
                            )
                        }
                        // k=3 because lazy. Maybe change this if needed later on
                    }
                    Token.Operator.Type.LeftBracket -> {
                        next()

                        val index = parseExpression(
                            anc = anc +
                                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                                FirstFollowUtils.firstSetPostfixOp
                        )

                        val rBracket = expectOperator(
                            Token.Operator.Type.RightBracket,
                            anc + FirstFollowUtils.firstSetPostfixOp
                        ) { "expected `]`" }

                        val accessExpression = rBracket.map {
                            AST.ArrayAccessExpression(target, index)
                        }
                        parsePostfixOp(accessExpression, anc)
                    }
                    else -> target
                }
            else -> target
        }
    }

    private fun parseUnaryExpression(anc: AnchorUnion): Parsed<AST.Expression> {
        return when (val peeked = peek()) {
            is Token.Operator ->
                when (peeked.type) {
                    Token.Operator.Type.Not -> {
                        next()

                        val innerExpression = parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators)
                        AST.UnaryExpression(
                            innerExpression,
                            AST.UnaryExpression.Operation.NOT
                        ).wrapValid(peeked.range.extend(innerExpression.range))
                    }
                    Token.Operator.Type.Minus -> {
                        next()

                        val innerExpression = parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators)
                        AST.UnaryExpression(
                            innerExpression,
                            AST.UnaryExpression.Operation.MINUS
                        ).wrapValid(peeked.range.extend(innerExpression.range))
                    }
                    else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
                }
            else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
        }
    }

    internal fun parseExpression(
        minPrecedence: Int = 1,
        anc: AnchorUnion
    ): Parsed<AST.Expression> {
        var result = parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators)
        var currentToken = peek()

        while (
            currentToken is Token.Operator &&
            (currentToken.type.toASTOperation()?.precedence?.let { it >= minPrecedence } == true)
        ) {
            val op = currentToken.type.toASTOperation()!!

            next()

            val rhs = parseExpression(
                when (op.associativity) {
                    AST.BinaryExpression.Operation.Associativity.LEFT -> op.precedence + 1
                    else -> op.precedence
                },
                anc + FirstFollowUtils.allExpressionOperators
            )
            result = AST.BinaryExpression(result, rhs, op).wrapValid(result.range.extend(rhs.range))
            currentToken = peek()
        }
        return result
    }

    internal fun parseClassDeclarations(anc: AnchorUnion): List<Parsed<AST.ClassDeclaration>> {
        return buildList {
            while (peek(0) !is Token.Eof) {
                // manual intervention: we read away one visibility modifier if present. Those are illegal here, but we
                // avoid many follow-up errors if we do that. It isn't totally dumb, considering java allows them
                var illegalVisibilityModifier = false
                if (peek() in FirstFollowUtils.visibilityTokens) {
                    reportError(next(), "classes must not have visibility modifiers")
                    illegalVisibilityModifier = true
                }

                val classKeyword = expectKeyword(
                    Token.Keyword.Type.Class,
                    anc +
                        anchorSetOf(
                            Token.Identifier.Placeholder,
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                ) { "expected class declaration" }

                val ident = expect<Token.Identifier>(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                            Token.Eof()
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                ) { "expected class name" }

                val parsedIdent = ident.map { it.name }

                val lBrace = expectOperator(
                    Token.Operator.Type.LeftBrace,
                    anc +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                        FirstFollowUtils.firstSetClassMembers
                ) {
                    "missing opening brace"
                }

                val classMembers = parseClassMembers(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)))

                val rBrace = expectOperator(Token.Operator.Type.RightBrace, anc) {
                    "missing closing brace"
                }

                val sourceRange = classKeyword.range.extend(rBrace.range)
                if (classKeyword is Parsed.Valid && ident is Parsed.Valid && lBrace is Parsed.Valid && rBrace is Parsed.Valid && !illegalVisibilityModifier) {
                    add(AST.ClassDeclaration(parsedIdent, classMembers).wrapValid(sourceRange))
                } else {
                    add(AST.ClassDeclaration(parsedIdent, classMembers).wrapErroneous(sourceRange))
                }
            }
        }
    }

    private fun parseClassMembers(anc: AnchorUnion): List<Parsed<AST.ClassMember>> {
        return buildList {
            var peeked = peek(0)

            while (true) {
                // read class members while we find visibility tokens. Most of them won't be accepted, but it will
                // improve error messages
                while (peeked in FirstFollowUtils.visibilityTokens) {
                    add(parseClassMember(anc + FirstFollowUtils.firstSetClassMember))
                    peeked = peek(0)
                }

                /*
                 * Manual intervention: Strictly following anchor sets and SLL parsing, we would expect the end of the
                 * class file here, because we did not encounter another `public`. But if we do not see an `}`, we assume
                 * that all following tokens are miss-placed and recover until the next `class` definition starts. This
                 * is stupid however, because this means that one missing `public` will result in all following members
                 * being skipped.
                 * So instead we check if the peeked token is a valid start of a class member after a `public`, and
                 * if so, we will parse it anyway (resulting in an error because `public` is missing, but good recovery
                 * after that). Then, we will try and parse more members starting at `public` again. However, if the
                 * peeked token is not valid even after a `public` token, we will recover towards the next `public` token
                 * (or the end of class as usual).
                 */

                if (peeked !in anc.provide() /* there are only more members if we aren't in follow(classmembers) */) {
                    val semiLegalAnchorSet =
                        FirstFollowUtils.firstSetFieldMethodPrefix + FirstFollowUtils.firstSetMainMethodPrefix
                    if (peeked in semiLegalAnchorSet.provide()) {
                        // this will be illegal, but we get better error reporting from it
                        add(parseClassMember(anc + FirstFollowUtils.visibilityTokens))
                    } else {
                        reportError(peeked, "expected class member definition")
                        recover(anc + FirstFollowUtils.visibilityTokens)
                    }
                    peeked = peek(0)
                } else {
                    break
                }
            }
        }
    }

    private fun parseClassMember(anc: AnchorUnion): Parsed<AST.ClassMember> {
        val publicKeyword = expectKeyword(
            Token.Keyword.Type.Public,
            anc + anchorSetOf(
                Token.Keyword(Token.Keyword.Type.Static),
                Token.Keyword(Token.Keyword.Type.Int),
                Token.Keyword(Token.Keyword.Type.Boolean),
                Token.Keyword(Token.Keyword.Type.Void),
                Token.Identifier.Placeholder
            )
        ) { "class members must be public" }

        val childNode = when (val token = peek(0)) {
            is Token.Keyword -> {
                when (token.type) {
                    Token.Keyword.Type.Static -> parseMainMethod(anc)
                    Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                        parseFieldMethodPrefix(anc)
                    else -> {
                        reportError(token, "expected `static` or (return) type identifier")
                        recover(anc)
                        return Parsed.Error(token.range, null)
                    }
                }
            }
            is Token.Identifier -> {
                parseFieldMethodPrefix(anc)
            }
            else -> {
                reportError(token, "expected field or method declaration")
                recover(anc)
                return Parsed.Error(token.range, null)
            }
        }

        return if (publicKeyword.isValid) {
            childNode
        } else {
            childNode.markErroneous()
        }
    }

    private fun parseMainMethod(anc: AnchorUnion): Parsed<AST.MainMethod> {
        val staticKeyword = expectKeyword(
            Token.Keyword.Type.Static,
            anc +
                anchorSetOf(
                    Token.Keyword(Token.Keyword.Type.Void),
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "main method must be `static`" }

        val voidKeyword = expectKeyword(
            Token.Keyword.Type.Void,
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "main method must return `void`" }

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "expected function name `main`" }

        val leftParen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        ) { "missing opening parenthesis" }

        // manually check if a parameter can be parsed before trying, so we can report a more sensible error message
        // than `expected type`
        val peeked = peek()
        val parameter = if (peeked in FirstFollowUtils.firstSetParameter) {
            parseParameter(
                anc +
                    anchorSetOf(
                        Token.Operator(Token.Operator.Type.RParen),
                        Token.Keyword(Token.Keyword.Type.Throws),
                    ) +
                    FirstFollowUtils.firstSetBlock
            )
        } else {
            reportError(peeked, "expected one parameter of type `String[]`")
            recover(
                anc +
                    anchorSetOf(
                        Token.Operator(Token.Operator.Type.RParen),
                        Token.Keyword(Token.Keyword.Type.Throws),
                    ) +
                    FirstFollowUtils.firstSetBlock
            )
            Parsed.Error(peeked.range, null)
        }

        val rightParen = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        ) {
            if (peek() in FirstFollowUtils.firstSetParameter) {
                "main method may only have one parameter of type `String[]`"
            } else {
                "expected closing parenthesis"
            }
        }

        val maybeThrowsToken = peek(0)
        val throwsException =
            if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
                parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
            } else {
                null
            }

        val block = parseBlock(anc)

        val parsedIdent = ident.map { it.name }
        return if (staticKeyword.isValid && voidKeyword.isValid && leftParen.isValid &&
            rightParen.isValid
        ) {
            AST.MainMethod(
                parsedIdent,
                AST.Type.Void.wrapValid(voidKeyword.range),
                listOf(parameter),
                block,
                throwsException
            ).wrapValid(staticKeyword.range.extend(block.range))
        } else {
            AST.MainMethod(
                parsedIdent,
                AST.Type.Void.wrapValid(voidKeyword.range),
                listOf(parameter),
                block,
                throwsException
            ).wrapErroneous(staticKeyword.range.extend(block.range))
        }
    }

    private fun parseFieldMethodPrefix(anc: AnchorUnion): Parsed<AST.ClassMember> {
        val type = parseType(
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        )

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        ) { "expected identifier" }

        return when (val fieldMethodRestToken = peek(0)) {
            is Token.Operator -> {
                when (fieldMethodRestToken.type) {
                    Token.Operator.Type.Semicolon -> parseField(ident, type)
                    Token.Operator.Type.LParen -> parseMethod(ident, type, anc)
                    else -> {
                        reportError(
                            fieldMethodRestToken,
                            "illegal class member declaration. expected either a method declaration or `;`",
                        )
                        recover(anc)
                        Parsed.Error(fieldMethodRestToken.range, null)
                    }
                }
            }
            else -> {
                reportError(
                    fieldMethodRestToken,
                    "illegal class member declaration. expected either `;` or `(`.",
                )
                recover(anc)
                Parsed.Error(fieldMethodRestToken.range, null)
            }
        }
    }

    private fun parseField(
        ident: Parsed<Token.Identifier>,
        type: Parsed<AST.Type>
    ): Parsed<AST.Field> {
        next()

        return AST.Field(
            ident.map { it.name },
            type
        ).wrapValid(type.range.extend(ident.range))
    }

    private fun parseMethod(
        ident: Parsed<Token.Identifier>,
        type: Parsed<AST.Type>,
        anc: AnchorUnion
    ): Parsed<AST.Method> {
        next()

        val maybeRParenToken = peek(0)
        val parameters =
            if (!(maybeRParenToken is Token.Operator && maybeRParenToken.type == Token.Operator.Type.RParen)) {
                parseParameters(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.RParen),
                            Token.Keyword(Token.Keyword.Type.Throws)
                        ) +
                        FirstFollowUtils.firstSetBlock
                )
            } else emptyList()

        val closingParenthesis = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        ) { "expected `)`" }

        val maybeThrowsToken = peek(0)
        val throwsException =
            if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
                parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
            } else {
                null
            }

        val block = parseBlock(anc)

        if (closingParenthesis.isValid) {
            return AST.Method(
                ident.map { it.name },
                type,
                parameters,
                block,
                throwsException
            ).wrapValid(ident.range.extend(block.range))
        } else {
            return AST.Method(
                ident.map { it.name },
                type,
                parameters,
                block,
                throwsException
            ).wrapErroneous(ident.range.extend(block.range))
        }
    }

    internal fun parseBlock(anc: AnchorUnion): Parsed<AST.Block> {
        val openingBrace = expectOperator(
            Token.Operator.Type.LeftBrace,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                FirstFollowUtils.firstSetBlockStatement
        ) { "expected opening brace" }

        val maybeRightBrace = peek(0)

        val resultBlock = AST.Block(
            if (!(maybeRightBrace is Token.Operator && maybeRightBrace.type == Token.Operator.Type.RightBrace)) {
                parseBlockStatements()
            } else {
                emptyList()
            }
        )

        val closingBrace = expectOperator(Token.Operator.Type.RightBrace, anc) { "expected closing brace" }

        return if (openingBrace.isValid && closingBrace.isValid) {
            resultBlock.wrapValid(openingBrace.range.extend(closingBrace.range))
        } else {
            resultBlock.wrapErroneous(openingBrace.range.extend(closingBrace.range))
        }
    }

    private fun parseBlockStatements(): List<Parsed<AST.BlockStatement>> {
        // at least one should exist at this point.
        return buildList {
            var peeked = peek(0)

            /*
             * Intervention: because the loop waits for a specific token to arise, it makes zero sense to recover to
             * tokens from anchor sets outside the loop. We will therefore replace the anchor set with one that
             * contains only tokens from the loop condition, to prevent the parser from spinning on miss-placed tokens
             * that are in the anchor set.
             */
            val loopAnchor = anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace), Token.Eof())
            while (peeked !in loopAnchor) {
                add(parseBlockStatement(loopAnchor + FirstFollowUtils.firstSetBlockStatement))
                peeked = peek(0)
            }
        }
    }

    private fun parseBlockStatement(anc: AnchorUnion): Parsed<AST.BlockStatement> {
        return when (val firstToken = peek(0)) {
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If,
                    Token.Keyword.Type.While,
                    Token.Keyword.Type.Return,
                    Token.Keyword.Type.Null,
                    Token.Keyword.Type.False,
                    Token.Keyword.Type.True,
                    Token.Keyword.Type.This,
                    Token.Keyword.Type.New -> parseStatement(anc).map { AST.StmtWrapper(it) }

                    Token.Keyword.Type.Int,
                    Token.Keyword.Type.Boolean,
                    Token.Keyword.Type.Void -> parseLocalVariableDeclarationStatement(anc)

                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Parsed.Error(firstToken.range, null)
                    }
                }
            }
            is Token.Literal -> parseStatement(anc).map { AST.StmtWrapper(it) }
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace,
                    Token.Operator.Type.Semicolon,
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseStatement(anc).map { AST.StmtWrapper(it) }

                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Parsed.Error(firstToken.range, null)
                    }
                }
            }
            is Token.Identifier -> {
                // Lookahead = 3 needed, here!
                when (val secondToken = peek(1)) {
                    is Token.Identifier -> parseLocalVariableDeclarationStatement(anc)
                    is Token.Operator -> {
                        if (secondToken.type == Token.Operator.Type.LeftBracket) {
                            when (val thirdToken = peek(2)) {
                                is Token.Operator -> {
                                    if (thirdToken.type == Token.Operator.Type.RightBracket) {
                                        parseLocalVariableDeclarationStatement(anc)
                                    } else {
                                        parseStatement(anc).map { AST.StmtWrapper(it) }
                                    }
                                }
                                else -> parseStatement(anc).map { AST.StmtWrapper(it) }
                            }
                        } else {
                            parseStatement(anc).map { AST.StmtWrapper(it) }
                        }
                    }
                    else -> parseStatement(anc).map { AST.StmtWrapper(it) }
                }
            }
            else -> {
                reportError(
                    firstToken,
                    "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                )
                recover(anc)
                return Parsed.Error(firstToken.range, null)
            }
        }
    }

    internal fun parseStatement(anc: AnchorUnion): Parsed<AST.Statement> {
        return when (val firstToken = peek(0)) {
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace -> parseBlock(anc)
                    Token.Operator.Type.Semicolon -> parseEmptyStatement(firstToken)
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseExpressionStatement(anc)
                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Parsed.Error(firstToken.range, null)
                    }
                }
            }
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If -> parseIfStatement(firstToken, anc)
                    Token.Keyword.Type.While -> parseWhileStatement(firstToken, anc)
                    Token.Keyword.Type.Return -> parseReturnStatement(firstToken, anc)
                    Token.Keyword.Type.Null -> parseExpressionStatement(anc)
                    Token.Keyword.Type.False -> parseExpressionStatement(anc)
                    Token.Keyword.Type.True -> parseExpressionStatement(anc)
                    Token.Keyword.Type.This -> parseExpressionStatement(anc)
                    Token.Keyword.Type.New -> parseExpressionStatement(anc)
                    else -> {
                        reportError(
                            firstToken,
                            "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                        )
                        recover(anc)
                        return Parsed.Error(firstToken.range, null)
                    }
                }
            }
            is Token.Literal -> parseExpressionStatement(anc)
            is Token.Identifier -> parseExpressionStatement(anc)
            else -> {
                reportError(
                    firstToken,
                    "illegal token: `${firstToken.debugRepr}`, expected statement, block, or expression",
                )
                recover(anc)
                return Parsed.Error(firstToken.range, null)
            }
        }
    }

    private fun parseReturnStatement(returnKeyword: Token, anc: AnchorUnion): Parsed<AST.ReturnStatement> {
        next()

        val maybeSemicolon = peek(0)
        var returnValue: Parsed<AST.Expression>? = null
        if (!(maybeSemicolon is Token.Operator && maybeSemicolon.type == Token.Operator.Type.Semicolon)) {
            returnValue = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        }

        next()

        return AST.ReturnStatement(returnValue)
            .wrapValid(returnValue?.range?.let { returnKeyword.range.extend(it) } ?: returnKeyword.range)
    }

    private fun parseIfStatement(ifKeyword: Token, anc: AnchorUnion): Parsed<AST.IfStatement> {
        next()

        val lparen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Else),
                ) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        ) { "missing `(`: if-conditions must be wrapped in parenthesis" }

        val condition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        )

        val rparen = expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        ) { "missing `)`: if-conditions must be wrapped in parenthesis" }

        val trueStatement = parseStatement(anc + anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)))

        val maybeElseToken = peek(0)
        var falseStatement: Parsed<AST.Statement>? = null
        if (maybeElseToken is Token.Keyword && maybeElseToken.type == Token.Keyword.Type.Else) {
            next()
            falseStatement = parseStatement(anc)
        }

        var ifStatementRange =
            ifKeyword.range.extend(trueStatement.range)
        if (falseStatement != null) {
            ifStatementRange = ifStatementRange.extend(falseStatement.range)
        }

        return if (lparen.isValid && rparen.isValid) {
            AST.IfStatement(
                condition,
                trueStatement,
                falseStatement
            ).wrapValid(ifStatementRange)
        } else {
            AST.IfStatement(
                condition,
                trueStatement,
                falseStatement
            ).wrapErroneous(ifStatementRange)
        }
    }

    private fun parseWhileStatement(whileKeyword: Token, anc: AnchorUnion): Parsed<AST.WhileStatement> {
        next()

        val lparen = expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        ) { "missing `(`: loop-conditions must be wrapped in parenthesis" }

        val loopCondition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetStatement
        )

        val rparen = expectOperator(
            Token.Operator.Type.RParen,
            anc + FirstFollowUtils.firstSetStatement
        ) { "missing `)`: loop-conditions must be wrapped in parenthesis" }

        val loopBodyStatement = parseStatement(anc)

        val whileStatementRange = whileKeyword.range.extend(rparen.range)
        return if (lparen.isValid && rparen.isValid) {
            AST.WhileStatement(loopCondition, loopBodyStatement).wrapValid(whileStatementRange)
        } else {
            AST.WhileStatement(loopCondition, loopBodyStatement).wrapErroneous(whileStatementRange)
        }
    }

    private fun parseEmptyStatement(tokenSemicolon: Token): Parsed<AST.Statement> {
        next()
        return AST.emptyStatement.wrapValid(tokenSemicolon.range)
    }

    private fun parseLocalVariableDeclarationStatement(anc: AnchorUnion): Parsed<AST.LocalVariableDeclarationStatement> {
        val type = parseType(
            anc + anchorSetOf(
                Token.Identifier.Placeholder,
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        )

        val varName = expectIdentifier(
            anc + anchorSetOf(
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        ) { "expected identifier" }

        val initializer = when (val nextToken = peek()) {
            is Token.Operator ->
                if (nextToken.type == Token.Operator.Type.Assign) {
                    next()
                    parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
                } else {
                    null
                }
            else -> null
        }

        val semicolon = expectOperator(Token.Operator.Type.Semicolon, anc) { "expected `;`" }

        val declarationRange = type.range.extend(semicolon.range)
        return if (semicolon.isValid) {
            AST.LocalVariableDeclarationStatement(varName.map { it.name }, type, initializer)
                .wrapValid(declarationRange)
        } else {
            AST.LocalVariableDeclarationStatement(
                varName.map { it.name },
                type,
                initializer
            ).wrapErroneous(declarationRange)
        }
    }

    private fun parseExpressionStatement(anc: AnchorUnion): Parsed<AST.ExpressionStatement> {
        val expr = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        val semicolon = expectOperator(Token.Operator.Type.Semicolon, anc) { "expected `;`" }

        val statementRange = expr.range.extend(semicolon.range)
        return if (semicolon.isValid) {
            AST.ExpressionStatement(expr).wrapValid(statementRange)
        } else {
            AST.ExpressionStatement(expr).wrapErroneous(statementRange)
        }
    }

    private fun parseMethodRest(anc: AnchorUnion): Parsed<Symbol> {
        next()

        return expectIdentifier(anc) { "missing identifier. `throws` requires an exception type" }.map { it.name }
    }

    private fun parseParameters(anc: AnchorUnion): List<Parsed<AST.Parameter>> {
        return buildList {
            add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))

            var maybeCommaToken = peek(0)
            while (maybeCommaToken is Token.Operator && maybeCommaToken.type == Token.Operator.Type.Comma) {
                next()
                add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))
                maybeCommaToken = peek(0)
            }
        }
    }

    private fun parseParameter(anc: AnchorUnion): Parsed<AST.Parameter> {
        val type = parseType(anc + anchorSetOf(Token.Identifier.Placeholder))
        val ident = expectIdentifier(anc) { "expected parameter name identifier" }

        return AST.Parameter(ident.map(Token.Identifier::name), type).wrapValid(type.range.extend(ident.range))
    }

    private fun parseType(anc: AnchorUnion): Parsed<AST.Type> {
        val basicType = parseBasicType(anc + FirstFollowUtils.firstSetTypeArrayRecurse)

        val maybeLeftBracket = peek(0)
        if (maybeLeftBracket is Token.Operator && maybeLeftBracket.type == Token.Operator.Type.LeftBracket) {
            return parseTypeArrayRecurse(basicType, anc)
        }
        return basicType
    }

    private fun parseTypeArrayRecurse(
        basicType: Parsed<AST.Type>,
        anc: AnchorUnion
    ): Parsed<AST.Type.Array> {
        next()

        val rightBracket = expectOperator(
            Token.Operator.Type.RightBracket,
            anc + FirstFollowUtils.firstSetTypeArrayRecurse
        ) { "illegal array type expression. expected `]`" }

        val maybeAnotherLBracket = peek(0)
        // TODO: check if correnct. (Probably not)
        val range = basicType.range.extend(rightBracket.range)
        return if (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) {
            if (rightBracket.isValid) {
                AST.Type.Array(parseTypeArrayRecurse(basicType, anc)).wrapValid(range)
            } else {
                AST.Type.Array(parseTypeArrayRecurse(basicType, anc)).wrapErroneous(range)
            }
        } else {
            if (rightBracket.isValid) {
                AST.Type.Array(basicType).wrapValid(range)
            } else {
                AST.Type.Array(basicType).wrapErroneous(range)
            }
        }
    }

    private fun parseBasicType(anc: AnchorUnion): Parsed<AST.Type> {
        return when (val peekedToken = peek()) {
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Int -> {
                        next()
                        AST.Type.Integer.wrapValid(peekedToken.range)
                    }
                    Token.Keyword.Type.Boolean -> {
                        next()
                        AST.Type.Boolean.wrapValid(peekedToken.range)
                    }
                    Token.Keyword.Type.Void -> {
                        next()
                        AST.Type.Void.wrapValid(peekedToken.range)
                    }
                    else -> {
                        reportError(peekedToken, "illegal token `${peekedToken.debugRepr}`. expected type")
                        recover(anc)
                        return Parsed.Error(peekedToken.range, null)
                    }
                }
            }
            is Token.Identifier -> {
                val t = expectIdentifier(anc) { "expected type identifier" }
                AST.Type.Class(t.map { it.name }).wrapValid(t.range)
            }
            else -> {
                reportError(peekedToken, "illegal token `${peekedToken.debugRepr}`. expected type")
                recover(anc)
                return Parsed.Error(peekedToken.range)
            }
        }
    }
}
