package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.lex.AbstractLexer
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.buffer
import kotlinx.coroutines.flow.produceIn

/**
 * Asynchronous parser that consumes a lexer flow generated by [AbstractLexer.tokens] and generates an [ASTNode] from
 * it.
 *
 * @param lexer [AbstractLexer] implementation providing a flow of [edu.kit.compiler.Token]
 */
class Parser(private val lexer: AbstractLexer) {
    
    /**
     * The lookahead buffer that provides the token stream and preloads them, when a lookahead is required
     */
    private lateinit var lookaheadBuffer: LookaheadBuffer<Token>
    
    /**
     * Parse the lexer stream into an AST. Suspends when the lexer isn't fast enough.
     */
    suspend fun parse(): ASTNode = coroutineScope {
        lookaheadBuffer = LookaheadBuffer(lexer.tokens().buffer().produceIn(this@coroutineScope))
        
        val classDeclarations = parseClassDeclarations()
        TODO("return constructProgramNode(classDeclarations)")
    }
    
    suspend fun parseClassDeclarations(): List<ASTNode> {
        while (lookaheadBuffer.peek(0) != Token.Eof) {
            expectKeyword(Token.Keyword.Type.Class)
            val ident = expect<Token.Identifier>()
            expectOperator(Token.Operator.Type.LeftBrace)
            val classMembers = parseClassMembers()
            expectOperator(Token.Operator.Type.RightBrace)
            
            // val classNode constructClassNode(ident, classMembers)
        }
        
        expect<Token.Eof>()
        
        return TODO()
    }
    
    suspend fun parseClassMembers(): List<ASTNode> {
        TODO()
    }
    
    private suspend inline fun expectOperator(type: Token.Operator.Type): Token.Operator {
        val token = lookaheadBuffer.get()
        if (token !is Token.Operator)
            enterPanicMode()
        
        if (token.type == type)
            return token
        else
            enterPanicMode()
    }
    
    private suspend inline fun expectKeyword(type: Token.Keyword.Type): Token.Keyword {
        val token = lookaheadBuffer.get()
        if (token !is Token.Keyword)
            enterPanicMode()
        
        if (token.type == type)
            return token
        else
            enterPanicMode()
    }
    
    /**
     * Expect and return a token of type [T].
     */
    private suspend inline fun <reified T : Token> expect(): T {
        val token = lookaheadBuffer.get()
        
        if (token is T)
            return token
        else
            enterPanicMode()
    }
    
    // TODO: this should probably not return `Nothing`, but this way the type system just eats it at the moment
    private fun enterPanicMode(): Nothing {
        // very black magic
        // such panic
        // much confusing
        // wow
        TODO("*explosion sounds*")
    }
}