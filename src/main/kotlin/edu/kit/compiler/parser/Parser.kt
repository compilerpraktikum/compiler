package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.lex.AbstractLexer
import kotlinx.coroutines.flow.Flow

/**
 * Asynchronous parser that consumes a lexer flow generated by [AbstractLexer.tokens] and generates an [ASTNode] from
 * it.
 *
 * @param lexer [AbstractLexer] implementation providing a flow of [edu.kit.compiler.Token]
 */
class Parser(tokens: Flow<Token>) : AbstractParser(tokens) {
    /**
     * Parse the lexer stream into an AST. Suspends when the lexer isn't fast enough.
     */
    override suspend fun parseAST(): ASTNode {
        val classDeclarations = parseClassDeclarations()
        TODO("return constructProgramNode(classDeclarations)")
    }

    suspend fun parseClassDeclarations(): List<ASTNode> {
        while (peek(0) != Token.Eof) {
            expectKeyword(Token.Keyword.Type.Class)
            val ident = expect<Token.Identifier>()
            expectOperator(Token.Operator.Type.LeftBrace)
            val classMembers = parseClassMembers()
            expectOperator(Token.Operator.Type.RightBrace)

            // val classNode constructClassNode(ident, classMembers)
        }

        expect<Token.Eof>()

        return TODO()
    }

    suspend fun parseClassMembers(): List<ASTNode> {
        TODO()
    }

    private suspend inline fun expectOperator(type: Token.Operator.Type): Token.Operator {
        val token = next()
        if (token !is Token.Operator)
            enterPanicMode()

        if (token.type == type)
            return token
        else
            enterPanicMode()
    }

    private suspend inline fun expectKeyword(type: Token.Keyword.Type): Token.Keyword {
        val token = next()
        if (token !is Token.Keyword)
            enterPanicMode()

        if (token.type == type)
            return token
        else
            enterPanicMode()
    }
}
