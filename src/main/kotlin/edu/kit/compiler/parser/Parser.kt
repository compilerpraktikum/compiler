package edu.kit.compiler.parser

import edu.kit.compiler.Token
import edu.kit.compiler.ast.AST
import edu.kit.compiler.ast.Lenient
import edu.kit.compiler.ast.Of
import edu.kit.compiler.ast.Type
import edu.kit.compiler.ast.toASTOperation
import edu.kit.compiler.ast.wrapValid
import edu.kit.compiler.lex.Lexer

private val Token.isRelevantForSyntax
    get() = !(this is Token.Whitespace || this is Token.Comment)

/**
 * Parser that consumes a token sequence generated by [Lexer.tokens] and generates an abstract syntax tree from it.
 *
 * @param[tokens] [sequence][Sequence] of [tokens][edu.kit.compiler.Token]
 */
@ExperimentalStdlibApi
class Parser(tokens: Sequence<Token>) : AbstractParser(tokens.filter(Token::isRelevantForSyntax)) {

    /**
     * Parse the lexer stream into an AST.
     */
    override fun parse(): AST.Program<Lenient<Of>, Lenient<Of>, Lenient<Of>, Lenient<Of>> {
        val classDeclarations = parseClassDeclarations(anchorSetOf(Token.Eof).intoUnion())
        expect<Token.Eof>(anchorSetOf().intoUnion())
        return AST.Program(classDeclarations)
    }

    private fun parsePrimaryExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>>> {
        return when (val peekedToken = peek()) {
            is Token.Literal -> {
                next()
                AST.LiteralExpression(peekedToken.value).wrapValid() // TODO we should further specify ""type""
            }
            is Token.Operator -> {
                if (peekedToken.type == Token.Operator.Type.LParen) {
                    next()
                    val innerExpr = parseExpression(1, anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    expectOperator(Token.Operator.Type.RParen, anc)
                    innerExpr
                } else {
                    panicMode(anc)
                    TODO("not implemented: lenient nodes")
                }
            }
            is Token.Identifier -> {
                val reference = expectIdentifier(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.LParen),
                            Token.Operator(Token.Operator.Type.RParen)
                        ) +
                        FirstFollowUtils.firstSetArguments
                )

                val maybeLParent = peek(0)
                if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                    expectOperator(
                        Token.Operator.Type.LParen,
                        anc +
                            anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                            FirstFollowUtils.firstSetArguments
                    )
                    val arguments = parseArguments(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
                    expectOperator(Token.Operator.Type.RParen, anc)

                    AST.MethodInvocationExpression(null, reference.name, arguments).wrapValid() // todo ist das richtig?
                } else Lenient.Valid<AST.Expression<Lenient<Of>>>(AST.IdentifierExpression(reference.name))
            }
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Null -> {
                        next()
                        AST.LiteralExpression("null").wrapValid() // TODO better ast stuff}
                    }
                    Token.Keyword.Type.False -> {
                        next()
                        AST.LiteralExpression(false).wrapValid()
                    }
                    Token.Keyword.Type.True -> {
                        next()
                        AST.LiteralExpression(true).wrapValid()
                    }
                    Token.Keyword.Type.This -> {
                        next()
                        AST.LiteralExpression("this").wrapValid() // TODO better ast stuff
                    }
                    Token.Keyword.Type.New -> {
                        next()
                        parseNewObjectArrayExpression(anc)
                    }
                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            else -> {
                panicMode(anc)
                TODO("not implemented: lenient nodes")
            }
        }
    }

    private fun parseNewObjectArrayExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>>> {
        return when (val firstToken = peek()) {
            is Token.Keyword -> when (firstToken.type) {
                Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void -> parseNewArrayExpression(
                    anc
                ).wrapValid()
                else -> {
                    panicMode(anc)
                    TODO("not implemented: lenient nodes")
                }
            }
            is Token.Identifier -> {
                // k=2
                when (val secondToken = peek(1)) {
                    is Token.Operator -> {
                        when (secondToken.type) {
                            Token.Operator.Type.LParen -> parseNewObjectExpression(anc).wrapValid()
                            Token.Operator.Type.LeftBracket -> parseNewArrayExpression(anc).wrapValid()
                            else -> {
                                panicMode(anc)
                                TODO("not implemented: lenient nodes")
                            }
                        }
                    }
                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            else -> {
                panicMode(anc)
                TODO("not implemented: lenient nodes")
            }
        }
    }

    private fun parseNewObjectExpression(anc: AnchorUnion): AST.Expression<Lenient<Of>> {
        val ident = expectIdentifier(
            anc + anchorSetOf(
                Token.Operator(Token.Operator.Type.LParen),
                Token.Operator(Token.Operator.Type.RParen)
            )
        )
        expectOperator(Token.Operator.Type.LParen, anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
        expectOperator(Token.Operator.Type.RParen, anc)
        return AST.NewObjectExpression(ident.name)
    }

    private fun parseNewArrayExpression(anc: AnchorUnion): AST.Expression<Lenient<Of>> {
        val basicType = parseBasicType(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LeftBracket),
                    Token.Operator(Token.Operator.Type.RightBracket)
                ) +
                FirstFollowUtils.firstSetExpression
        )
        expectOperator(
            Token.Operator.Type.LeftBracket,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                FirstFollowUtils.firstSetExpression
        )
        val indexExpression = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)))
        expectOperator(Token.Operator.Type.RightBracket, anc)
        val arrayType = parseNewArrayExpressionTypeArrayRecurse(Type.Array(basicType), anc)
        return AST.NewArrayExpression(arrayType, indexExpression)
    }

    private fun parseNewArrayExpressionTypeArrayRecurse(basicType: Type.Array, anc: AnchorUnion): Type.Array {
        val maybeAnotherLBracket = peek(0)
        val maybeAnotherRBracket =
            peek(1) // special case for NewArrayExpression in combination with ArrayAccess (in "PostfixExpression -> PrimaryExpression (PostfixOp)*" Production)
        return if (
            (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) &&
            (maybeAnotherRBracket is Token.Operator && maybeAnotherRBracket.type == Token.Operator.Type.RightBracket)
        ) {
            expectOperator(Token.Operator.Type.LeftBracket, anc)
            expectOperator(Token.Operator.Type.RightBracket, anc)
            Type.Array(parseNewArrayExpressionTypeArrayRecurse(basicType, anc))
        } else {
            basicType
        }
    }

    private fun parseArguments(anc: AnchorUnion): List<Lenient<AST.Expression<Lenient<Of>>>> {
        val arguments = mutableListOf<Lenient<AST.Expression<Lenient<Of>>>>()
        var nextToken = peek()
        while (!(nextToken is Token.Operator && nextToken.type == Token.Operator.Type.RParen)) {
            if (arguments.isNotEmpty()) expectOperator(
                Token.Operator.Type.Comma,
                anc +
                    FirstFollowUtils.firstSetExpression +
                    anchorSetOf(Token.Operator(Token.Operator.Type.RParen))
            )
            arguments += parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)))
            nextToken = peek()
        }
        return arguments
    }

    private fun parsePostfixExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>>> {
        val primaryExpression = parsePrimaryExpression(anc + FirstFollowUtils.firstSetPostfixOp)

        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot,
                    Token.Operator.Type.LeftBracket -> parsePostfixOp(
                        primaryExpression,
                        anc + FirstFollowUtils.firstSetPostfixOp
                    )
                    else -> return primaryExpression
                }
            else -> return primaryExpression
        }
    }

    private fun parsePostfixOp(target: Lenient<AST.Expression<Lenient<Of>>>, anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>>> {
        return when (val firstPeekedToken = peek()) {
            is Token.Operator ->
                when (firstPeekedToken.type) {
                    Token.Operator.Type.Dot -> {
                        expectOperator(
                            Token.Operator.Type.Dot,
                            anc +
                                anchorSetOf(
                                    Token.Identifier.Placeholder,
                                    Token.Operator(Token.Operator.Type.LParen),
                                    Token.Operator(Token.Operator.Type.RParen),
                                ) +
                                FirstFollowUtils.firstSetArguments +
                                FirstFollowUtils.firstSetPostfixOp
                        )

                        val ident = expectIdentifier(
                            anc +
                                anchorSetOf(
                                    Token.Operator(Token.Operator.Type.LParen),
                                    Token.Operator(Token.Operator.Type.RParen),
                                ) +
                                FirstFollowUtils.firstSetArguments +
                                FirstFollowUtils.firstSetPostfixOp
                        )
                        val maybeLParent = peek()
                        if (maybeLParent is Token.Operator && maybeLParent.type == Token.Operator.Type.LParen) {
                            // methodInvocation todo recurse
                            expectOperator(
                                Token.Operator.Type.LParen,
                                anc + anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                                    FirstFollowUtils.firstSetArguments +
                                    FirstFollowUtils.firstSetPostfixOp
                            )
                            val arguments = parseArguments(
                                anc +
                                    anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                                    FirstFollowUtils.firstSetPostfixOp
                            )
                            expectOperator(Token.Operator.Type.RParen, anc + FirstFollowUtils.firstSetPostfixOp)
                            parsePostfixOp(AST.MethodInvocationExpression(target, ident.name, arguments).wrapValid(), anc)
                        } else {
                            // fieldAccess todo recurse
                            parsePostfixOp(AST.FieldAccessExpression(target, ident.name).wrapValid(), anc)
                        }
                        // k=3 because lazy. Maybe change this if needed later on
                    }
                    Token.Operator.Type.LeftBracket -> {
                        expectOperator(
                            Token.Operator.Type.LeftBracket,
                            anc +
                                FirstFollowUtils.firstSetExpression +
                                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                                FirstFollowUtils.firstSetPostfixOp
                        )
                        val index = parseExpression(
                            anc = anc +
                                anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) +
                                FirstFollowUtils.firstSetPostfixOp
                        )
                        expectOperator(Token.Operator.Type.RightBracket, anc + FirstFollowUtils.firstSetPostfixOp)
                        parsePostfixOp(AST.ArrayAccessExpression(target, index).wrapValid(), anc)
                    }
                    else -> target
                }
            else -> target
        }
    }

    private fun parseUnaryExpression(anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>>> {
        // todo not exhausting first(follow) of parsePrimary!)
        // TODO parsePostfixExpression instead of parsePrimaryExpression !
        return when (val peeked = peek()) {
            is Token.Operator ->
                when (peeked.type) {
                    Token.Operator.Type.Not -> {
                        expectOperator(Token.Operator.Type.Not, anc + FirstFollowUtils.allExpressionOperators)
                        AST.UnaryExpression(
                            parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators),
                            AST.UnaryExpression.Operation.NOT
                        ).wrapValid()
                    }
                    Token.Operator.Type.Minus -> {
                        expectOperator(Token.Operator.Type.Minus, anc + FirstFollowUtils.allExpressionOperators)
                        AST.UnaryExpression(
                            parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators),
                            AST.UnaryExpression.Operation.MINUS
                        ).wrapValid()
                    }
                    else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
                }
            else -> parsePostfixExpression(anc + FirstFollowUtils.allExpressionOperators)
        }
    }

    internal fun parseExpression(minPrecedence: Int = 1, anc: AnchorUnion): Lenient<AST.Expression<Lenient<Of>>> {
        // todo: calculate anchorsets using all expression operators
        var result = parseUnaryExpression(anc + FirstFollowUtils.allExpressionOperators)
        var currentToken = peek()

        while (
            currentToken is Token.Operator &&
            (currentToken.type.toASTOperation()?.precedence?.let { it >= minPrecedence } == true)
        ) {
            val op = currentToken.type.toASTOperation()!!

            next()

            val rhs = parseExpression(
                when (op.associativity) {
                    AST.BinaryExpression.Operation.Associativity.LEFT -> op.precedence + 1
                    else -> op.precedence
                },
                anc + FirstFollowUtils.allExpressionOperators
            )
            result = AST.BinaryExpression(result, rhs, op).wrapValid()
            currentToken = peek()
        }
        return result
    }

    internal fun parseClassDeclarations(anc: AnchorUnion): List<Lenient<AST.ClassDeclaration<Lenient<Of>, Lenient<Of>, Lenient<Of>>>> {
        return buildList<Lenient<AST.ClassDeclaration<Lenient<Of>, Lenient<Of>, Lenient<Of>>>> {
            while (peek(0) != Token.Eof) {
                expectKeyword(
                    Token.Keyword.Type.Class,
                    anc +
                        anchorSetOf(
                            Token.Identifier.Placeholder,
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                )
                val ident = expect<Token.Identifier>(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.LeftBrace),
                            Token.Operator(Token.Operator.Type.RightBrace),
                            Token.Eof
                        ) +
                        FirstFollowUtils.firstSetClassMembers
                )
                expectOperator(
                    Token.Operator.Type.LeftBrace,
                    anc +
                        anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                        FirstFollowUtils.firstSetClassMembers
                )
                val classMembers = parseClassMembers(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)))
                expectOperator(Token.Operator.Type.RightBrace, anc)

                add(AST.ClassDeclaration(ident.name, classMembers).wrapValid())
            }
        }
    }

    private fun parseClassMembers(anc: AnchorUnion): List<Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>>>> {
        return buildList<Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>>>> {
            var peeked = peek(0)
            while (peeked is Token.Keyword && peeked.type == Token.Keyword.Type.Public) {
                add(parseClassMember(anc + anchorSetOf(Token.Keyword(Token.Keyword.Type.Public))))
                peeked = peek(0)
            }
        }
    }

    private fun parseClassMember(anc: AnchorUnion): Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>>> {
        expectKeyword(
            Token.Keyword.Type.Public,
            anc + anchorSetOf(
                Token.Keyword(Token.Keyword.Type.Static),
                Token.Keyword(Token.Keyword.Type.Int),
                Token.Keyword(Token.Keyword.Type.Boolean),
                Token.Keyword(Token.Keyword.Type.Void),
                Token.Identifier.Placeholder
            )
        )

        return when (val token = peek(0)) {
            is Token.Keyword -> {
                return when (token.type) {
                    Token.Keyword.Type.Static -> parseMainMethod(anc)
                    Token.Keyword.Type.Int, Token.Keyword.Type.Boolean, Token.Keyword.Type.Void ->
                        parseFieldMethodPrefix(anc)
                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            is Token.Identifier -> {
                parseFieldMethodPrefix(anc)
            }
            else -> {
                panicMode(anc)
                TODO("not implemented: lenient nodes")
            }
        }
    }

    private fun parseMainMethod(anc: AnchorUnion): Lenient<AST.MainMethod<Lenient<Of>, Lenient<Of>>> {
        expectKeyword(
            Token.Keyword.Type.Static,
            anc +
                anchorSetOf(
                    Token.Keyword(Token.Keyword.Type.Void),
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        )
        expectKeyword(
            Token.Keyword.Type.Void,
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        )

        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        )

        expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetParameter +
                FirstFollowUtils.firstSetBlock
        )
        val parameter = parseParameter(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws),
                ) +
                FirstFollowUtils.firstSetBlock
        )
        expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        )

        val maybeThrowsToken = peek(0)
        if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
            parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
        }

        val block = parseBlock(anc)
        return AST.MainMethod(
            ident.name,
            Type.Void,
            listOf(parameter),
            block
        ).wrapValid()
    }

    private fun parseFieldMethodPrefix(anc: AnchorUnion): Lenient<AST.ClassMember<Lenient<Of>, Lenient<Of>>> {
        val type = parseType(
            anc +
                anchorSetOf(
                    Token.Identifier.Placeholder,
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        )
        val ident = expectIdentifier(
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.Semicolon),
                    Token.Operator(Token.Operator.Type.LParen)
                )
        )
        return when (val fieldMethodRestToken = peek(0)) {
            is Token.Operator -> {
                when (fieldMethodRestToken.type) {
                    Token.Operator.Type.Semicolon -> parseField(ident, type, anc)
                    Token.Operator.Type.LParen -> parseMethod(ident, type, anc)
                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            else -> {
                panicMode(anc)
                TODO("not implemented: lenient nodes")
            }
        }
    }

    private fun parseField(ident: Token.Identifier, type: Type, anc: AnchorUnion): Lenient<AST.Field> {
        expectOperator(Token.Operator.Type.Semicolon, anc)
        return AST.Field(
            ident.name,
            type
        ).wrapValid()
    }

    private fun parseMethod(ident: Token.Identifier, type: Type, anc: AnchorUnion): Lenient<AST.Method<Lenient<Of>, Lenient<Of>>> {
        expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Throws)
                ) +
                FirstFollowUtils.firstSetBlock
        )
        val maybeRParenToken = peek(0)
        val parameters =
            if (!(maybeRParenToken is Token.Operator && maybeRParenToken.type == Token.Operator.Type.RParen)) {
                parseParameters(
                    anc +
                        anchorSetOf(
                            Token.Operator(Token.Operator.Type.RParen),
                            Token.Keyword(Token.Keyword.Type.Throws)
                        ) +
                        FirstFollowUtils.firstSetBlock
                )
            } else emptyList()
        expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Throws)) +
                FirstFollowUtils.firstSetBlock
        )

        val maybeThrowsToken = peek(0)
        val methodRest = if (maybeThrowsToken is Token.Keyword && maybeThrowsToken.type == Token.Keyword.Type.Throws) {
            parseMethodRest(anc + FirstFollowUtils.firstSetBlock)
        } else {
            null
        }
        val block = parseBlock(anc)
        return AST.Method<Lenient<Of>, Lenient<Of>>(
            ident.name,
            type,
            parameters,
            block,
            methodRest
        ).wrapValid()
    }

    internal fun parseBlock(anc: AnchorUnion): Lenient<AST.Block<Lenient<Of>, Lenient<Of>>> {
        expectOperator(
            Token.Operator.Type.LeftBrace,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)) +
                FirstFollowUtils.firstSetBlockStatement
        )

        val maybeRightBrace = peek(0)

        val resultBlock = AST.Block<Lenient<Of>, Lenient<Of>>(
            if (!(maybeRightBrace is Token.Operator && maybeRightBrace.type == Token.Operator.Type.RightBrace)) {
                parseBlockStatements(anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBrace)))
            } else {
                emptyList()
            }
        )

        expectOperator(Token.Operator.Type.RightBrace, anc)
        return resultBlock.wrapValid()
    }

    private fun parseBlockStatements(anc: AnchorUnion): List<Lenient<AST.BlockStatement<Lenient<Of>, Lenient<Of>>>> {
        // at least one should exist at this point.
        return buildList<Lenient<AST.BlockStatement<Lenient<Of>, Lenient<Of>>>> {
            var peeked = peek(0)
            while (!(peeked is Token.Operator && peeked.type == Token.Operator.Type.RightBrace)) {
                add(parseBlockStatement(anc + FirstFollowUtils.firstSetBlockStatement))
                peeked = peek(0)
            }
        }
    }

    private fun parseBlockStatement(anc: AnchorUnion): Lenient<AST.BlockStatement<Lenient<Of>, Lenient<Of>>> {
        // Statement ==> "{ | ; | if | while | return | null | false | true | INTEGER_LITERAL | ( | IDENT | this | new"
        // Statement: Auf IDENT folgt nie ein weiteres IDENT.
        // LocalVariableDeclarationStatement ==> "int | boolean | void | IDENT" x " IDENT " x " = | ; "
        return when (val firstToken = peek(0)) {
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If,
                    Token.Keyword.Type.While,
                    Token.Keyword.Type.Return,
                    Token.Keyword.Type.Null,
                    Token.Keyword.Type.False,
                    Token.Keyword.Type.True,
                    Token.Keyword.Type.This,
                    Token.Keyword.Type.New -> parseStatement(anc)

                    Token.Keyword.Type.Int,
                    Token.Keyword.Type.Boolean,
                    Token.Keyword.Type.Void -> parseLocalVariableDeclarationStatement(anc)

                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            is Token.Literal -> parseStatement(anc)
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace,
                    Token.Operator.Type.Semicolon,
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseStatement(anc)

                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            is Token.Identifier -> {
                // Lookahead = 3 needed, here!
                when (val secondToken = peek(1)) {
                    is Token.Identifier -> parseLocalVariableDeclarationStatement(anc)
                    is Token.Operator -> {
                        if (secondToken.type == Token.Operator.Type.LeftBracket) {
                            when (val thirdToken = peek(2)) {
                                is Token.Operator -> {
                                    if (thirdToken.type == Token.Operator.Type.RightBracket) {
                                        parseLocalVariableDeclarationStatement(anc)
                                    } else {
                                        parseStatement(anc)
                                    }
                                }
                                else -> parseStatement(anc)
                            }
                        } else {
                            parseStatement(anc)
                        }
                    }
                    else -> parseStatement(anc)
                }
            }
            else -> {
                panicMode(anc)
                TODO("not implemented: lenient nodes")
            }
        }
    }

    internal fun parseStatement(anc: AnchorUnion): Lenient<AST.Statement<Lenient<Of>, Lenient<Of>>> {
        return when (val firstToken = peek(0)) {
            is Token.Operator -> {
                when (firstToken.type) {
                    Token.Operator.Type.LeftBrace -> parseBlock(anc)
                    Token.Operator.Type.Semicolon -> parseEmptyStatement(anc)
                    Token.Operator.Type.Not,
                    Token.Operator.Type.Minus,
                    Token.Operator.Type.LParen -> parseExpressionStatement(anc)
                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            is Token.Keyword -> {
                when (firstToken.type) {
                    Token.Keyword.Type.If -> parseIfStatement(anc)
                    Token.Keyword.Type.While -> parseWhileStatement(anc)
                    Token.Keyword.Type.Return -> parseReturnStatement(anc)
                    Token.Keyword.Type.Null -> parseExpressionStatement(anc)
                    Token.Keyword.Type.False -> parseExpressionStatement(anc)
                    Token.Keyword.Type.True -> parseExpressionStatement(anc)
                    Token.Keyword.Type.This -> parseExpressionStatement(anc)
                    Token.Keyword.Type.New -> parseExpressionStatement(anc)
                    else -> {
                        panicMode(anc)
                        TODO("not implemented: lenient nodes")
                    }
                }
            }
            is Token.Literal -> parseExpressionStatement(anc)
            is Token.Identifier -> parseExpressionStatement(anc)
            else -> {
                panicMode(anc)
                TODO("not implemented: lenient nodes")
            }
        }
    }

    private fun parseReturnStatement(anc: AnchorUnion): Lenient<AST.ReturnStatement<Lenient<Of>>> {
        expectKeyword(
            Token.Keyword.Type.Return,
            anc + FirstFollowUtils.firstSetExpression + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon))
        )
        val maybeSemicolon = peek(0)
        var returnValue: Lenient<AST.Expression<Lenient<Of>>>? = null
        if (!(maybeSemicolon is Token.Operator && maybeSemicolon.type == Token.Operator.Type.Semicolon)) {
            returnValue = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        }
        expectOperator(Token.Operator.Type.Semicolon, anc)
        return AST.ReturnStatement(returnValue).wrapValid()
    }

    private fun parseIfStatement(anc: AnchorUnion): Lenient<AST.IfStatement<Lenient<Of>, Lenient<Of>>> {
        expectKeyword(
            Token.Keyword.Type.If,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.LParen),
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Else),
                ) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        )
        expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(
                    Token.Operator(Token.Operator.Type.RParen),
                    Token.Keyword(Token.Keyword.Type.Else),
                ) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        )
        val condition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen), Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        )
        expectOperator(
            Token.Operator.Type.RParen,
            anc +
                anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)) +
                FirstFollowUtils.firstSetStatement
        )
        val trueStatement = parseStatement(anc + anchorSetOf(Token.Keyword(Token.Keyword.Type.Else)))

        val maybeElseToken = peek(0)
        var falseStatement: Lenient<AST.Statement<Lenient<Of>, Lenient<Of>>>? = null
        if (maybeElseToken is Token.Keyword && maybeElseToken.type == Token.Keyword.Type.Else) {
            expectKeyword(Token.Keyword.Type.Else, anc + FirstFollowUtils.firstSetStatement)
            falseStatement = parseStatement(anc)
        }
        return AST.IfStatement(
            condition,
            trueStatement,
            falseStatement
        ).wrapValid()
    }

    private fun parseWhileStatement(anc: AnchorUnion): Lenient<AST.WhileStatement<Lenient<Of>, Lenient<Of>>> {
        expectKeyword(
            Token.Keyword.Type.While,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.LParen), Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        )
        expectOperator(
            Token.Operator.Type.LParen,
            anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetExpression +
                FirstFollowUtils.firstSetStatement
        )
        val loopCondition = parseExpression(
            anc = anc +
                anchorSetOf(Token.Operator(Token.Operator.Type.RParen)) +
                FirstFollowUtils.firstSetStatement
        )
        expectOperator(Token.Operator.Type.RParen, anc + FirstFollowUtils.firstSetStatement)
        val loopBodyStatement = parseStatement(anc)

        return AST.WhileStatement(loopCondition, loopBodyStatement).wrapValid()
    }

    private fun parseEmptyStatement(anc: AnchorUnion): Lenient<AST.EmptyStatement> {
        // todo: on error, return error-node
        expectOperator(Token.Operator.Type.Semicolon, anc)
        return AST.EmptyStatement.wrapValid()
    }

    private fun parseLocalVariableDeclarationStatement(anc: AnchorUnion): Lenient<AST.LocalVariableDeclarationStatement<Lenient<Of>>> {
        val type = parseType(
            anc + anchorSetOf(
                Token.Identifier.Placeholder,
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        )
        val varName = expectIdentifier(
            anc + anchorSetOf(
                Token.Operator(Token.Operator.Type.Assign),
                Token.Operator(Token.Operator.Type.Semicolon)
            )
        )
        val initializer = when (val nextToken = peek()) {
            is Token.Operator ->
                if (nextToken.type == Token.Operator.Type.Assign) {
                    next()
                    parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
                } else {
                    null
                }
            else -> null
        }
        expectOperator(Token.Operator.Type.Semicolon, anc)
        return AST.LocalVariableDeclarationStatement(varName.name, type, initializer)
            .wrapValid()
    }

    private fun parseExpressionStatement(anc: AnchorUnion): Lenient<AST.ExpressionStatement<Lenient<Of>>> {
        val expr = parseExpression(anc = anc + anchorSetOf(Token.Operator(Token.Operator.Type.Semicolon)))
        expectOperator(Token.Operator.Type.Semicolon, anc)
        return AST.ExpressionStatement(expr).wrapValid()
    }

    private fun parseMethodRest(anc: AnchorUnion): Token.Identifier {
        expectKeyword(Token.Keyword.Type.Throws, anc + anchorSetOf(Token.Identifier.Placeholder))
        return expectIdentifier(anc)
    }

    private fun parseParameters(anc: AnchorUnion): List<AST.Parameter> {
        return buildList {
            add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma)) + FirstFollowUtils.firstSetParameter))
            var maybeCommaToken = peek(0)
            while (maybeCommaToken is Token.Operator && maybeCommaToken.type == Token.Operator.Type.Comma) {
                expectOperator(
                    Token.Operator.Type.Comma,
                    anc + FirstFollowUtils.firstSetParameter + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))
                )
                add(parseParameter(anc + anchorSetOf(Token.Operator(Token.Operator.Type.Comma))))
                maybeCommaToken = peek(0)
            }
        }
    }

    private fun parseParameter(anc: AnchorUnion): AST.Parameter {
        val type = parseType(anc + anchorSetOf(Token.Identifier.Placeholder))
        val ident = expectIdentifier(anc)
        return AST.Parameter(
            ident.name,
            type
        )
    }

    private fun parseType(anc: AnchorUnion): Type {
        val basicType = parseBasicType(anc + FirstFollowUtils.firstSetTypeArrayRecurse)
        val maybeLeftBracket = peek(0)
        if (maybeLeftBracket is Token.Operator && maybeLeftBracket.type == Token.Operator.Type.LeftBracket) {
            return parseTypeArrayRecurse(basicType, anc)
        }
        return basicType
    }

    private fun parseTypeArrayRecurse(basicType: Type, anc: AnchorUnion): Type.Array {
        expectOperator(
            Token.Operator.Type.LeftBracket,
            anc + anchorSetOf(Token.Operator(Token.Operator.Type.RightBracket)) + FirstFollowUtils.firstSetTypeArrayRecurse
        )
        expectOperator(Token.Operator.Type.RightBracket, anc + FirstFollowUtils.firstSetTypeArrayRecurse)

        // TODO: in case of error, return an error-node
        val maybeAnotherLBracket = peek(0)
        return if (maybeAnotherLBracket is Token.Operator && maybeAnotherLBracket.type == Token.Operator.Type.LeftBracket) {
            Type.Array(parseTypeArrayRecurse(basicType, anc))
        } else {
            Type.Array(basicType)
        }
    }

    private fun parseBasicType(anc: AnchorUnion): Type {
        return when (val peekedToken = peek()) {
            is Token.Keyword -> {
                when (peekedToken.type) {
                    Token.Keyword.Type.Int -> {
                        next()
                        Type.Integer
                    }
                    Token.Keyword.Type.Boolean -> {
                        next()
                        Type.Boolean
                    }
                    Token.Keyword.Type.Void -> {
                        next()
                        Type.Void
                    }
                    else -> {
                        panicMode(anc)
                        TODO("lenient type node")
                    }
                }
            }
            is Token.Identifier -> {
                val t = expectIdentifier(anc)
                Type.Class(t.name)
            }
            else -> {
                panicMode(anc)
                TODO("lenient type node")
            }
        }
    }
}
